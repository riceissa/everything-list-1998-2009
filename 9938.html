<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<meta name="generator" content="hypermail 2.3.0, see http://www.hypermail-project.org/" />
<title>Re: Diagonalization (solution-sequel) from Tom Caylor on 2006-07-17 (everything)</title>
<meta name="Author" content="Tom Caylor (Daddycaylor.domain.name.hidden)" />
<meta name="Subject" content="Re: Diagonalization (solution-sequel)" />
<meta name="Date" content="2006-07-17" />
<style type="text/css">
/*<![CDATA[*/
/* To be incorporated in the main stylesheet, don't code it in hypermail! */
body {color: black; background: #ffffff}
dfn {font-weight: bold;}
pre { background-color:inherit;}
.head { border-bottom:1px solid black;}
.foot { border-top:1px solid black;}
th {font-style:italic;}
table { margin-left:2em;}map ul {list-style:none;}
#mid { font-size:0.9em;}
#received { float:right;}
address { font-style:inherit ;}
/*]]>*/
.quotelev1 {color : #990099}
.quotelev2 {color : #ff7700}
.quotelev3 {color : #007799}
.quotelev4 {color : #95c500}
.period {font-weight: bold}
</style>
</head>
<body>
<div class="head">
<h1>Re: Diagonalization (solution-sequel)</h1>
<!-- received="Mon Jul 17 16:43:16 2006" -->
<!-- isoreceived="20060717234316" -->
<!-- sent="Mon, 17 Jul 2006 13:42:14 -0700" -->
<!-- isosent="20060717204214" -->
<!-- name="Tom Caylor" -->
<!-- email="Daddycaylor.domain.name.hidden" -->
<!-- subject="Re: Diagonalization (solution-sequel)" -->
<!-- id="1153168934.765706.303780.domain.name.hidden" -->
<!-- charset="ISO-8859-1" -->
<!-- inreplyto="3307119af2c4129fa2e56a3f529d6dc8.domain.name.hidden" -->
<!-- expires="-1" -->
<map id="navbar" name="navbar">
<ul class="links">
<li>
<dfn>This message</dfn>:
[ <a href="#start9938" name="options1" id="options1" tabindex="1">Message body</a> ]
 [ More options (<a href="#options2">top</a>, <a href="#options3">bottom</a>) ]
</li>
<li>
<dfn>Related messages</dfn>:
<!-- unext="start" -->
[ <a href="9939.html" accesskey="d" title="1Z: &quot;Re: SV: Only Existence is necessary?&quot;">Next message</a> ]
[ <a href="9937.html" title="1Z: &quot;Re: SV: Only Existence is necessary?&quot;">Previous message</a> ]
[ <a href="9921.html" title="Bruno Marchal: &quot;Re: Diagonalization (solution-sequel)&quot;">In reply to</a> ]
<!-- unextthread="start" -->
[ <a href="9941.html" accesskey="t" title="Tom Caylor: &quot;Re: Diagonalization (solution-sequel)&quot;">Next in thread</a> ]
 [ <a href="#replies">Replies</a> ]
<!-- ureply="end" -->
</li>
</ul>
</map>
<ul class="links">
<li><a name="options2" id="options2"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg9938" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg9938" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg9938" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg9938" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</div>
<!-- body="start" -->
<div class="mail">
<address class="headers">
<span id="from">
<dfn>From</dfn>: Tom Caylor &lt;<a href="mailto:Daddycaylor.domain.name.hidden?Subject=Re%3A%20Diagonalization%20(solution-sequel)">Daddycaylor.domain.name.hidden</a>&gt;
</span><br />
<span id="date"><dfn>Date</dfn>: Mon, 17 Jul 2006 13:42:14 -0700</span><br />
</address>
<br />
Warning, I progressed in my thinking as I responded below, so please
<br />
read the whole post before taking time to respond/correct my earlier
<br />
paragraphs.
<br />
<br />Bruno Marchal wrote:
<br />
<em class="quotelev1">&gt; Le 15-juil.-06, à 02:56, Tom Caylor a écrit :
</em><br />
<em class="quotelev2">&gt; &gt; ...
</em><br />
<em class="quotelev2">&gt; &gt; You've written a sort of intuitive code for G above, where you say
</em><br />
<em class="quotelev2">&gt; &gt; &quot;generate&quot;.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Yes. With Church thesis fortran *is* universal.
</em><br />
<em class="quotelev1">&gt; Fortran, like Java, Python, Lisp, Diophantine equations, rational
</em><br />
<em class="quotelev1">&gt; unitary matrices or other rich recursively presented groups, etc...
</em><br />
<em class="quotelev1">&gt; Chose your favorite one, once and for all. To fiw the idea I take
</em><br />
<em class="quotelev1">&gt; fortran, and old and venerable programming language.
</em><br />
<em class="quotelev1">&gt; Those language are grammatically well defined.
</em><br />
<em class="quotelev1">&gt; So you *can* write a well defined precise (I would even say concrete)
</em><br />
<em class="quotelev1">&gt; program fortran capable of generating all fortran programs computing
</em><br />
<em class="quotelev1">&gt; function of one variable. It is enough to write a program which
</em><br />
<em class="quotelev1">&gt; generate successively all strings of length n, and which filter out
</em><br />
<em class="quotelev1">&gt; those strings which are not fortran one variable programs.
</em><br />
<em class="quotelev1">&gt; I gave an intuitive code just for not alarming people with piece of
</em><br />
<em class="quotelev1">&gt; code, but it should be clear that anyone knowing at least one
</em><br />
<em class="quotelev1">&gt; programming language, and knowing the notion of alphabetic order on a
</em><br />
<em class="quotelev1">&gt; finite set of symbols (like the keyboard buttons of a computer) should
</em><br />
<em class="quotelev1">&gt; be able to write, in that programming language, a program generating
</em><br />
<em class="quotelev1">&gt; (just generating) successively all the (one variable) programs in that
</em><br />
<em class="quotelev1">&gt; language. Then by coding &quot;finite inputs&quot; by natural numbers, you can
</em><br />
<em class="quotelev1">&gt; think of those programs as computing functions from N to N, or from
</em><br />
<em class="quotelev1">&gt; subset of N to N.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<br />OK.  I'm OK with this if it is &quot;just generating&quot; the programs.  I see
<br />
where I was getting wrapped around the self-referential axle by trying
<br />
to make the generation program self-aware.  But GEN just generates all
<br />
programs, so when it gets to &quot;itself&quot; it just generates the code and
<br />
then goes on to generating the next program, totally oblivious to the
<br />
fact that it just generated itself.
<br />
<br /><em class="quotelev1">&gt; If you agree with this, you agree with the fact that there is a
</em><br />
<em class="quotelev1">&gt; program, let us call it GEN, in fortran which generates the sequence of
</em><br />
<em class="quotelev1">&gt; codes P1 P2 P3 P4 P5 P6 ... Now the partial computable functions are
</em><br />
<em class="quotelev1">&gt; those functions computed by those programs, and I wrote the sequence of
</em><br />
<em class="quotelev1">&gt; those functions Fi. That is F1 F2 F3 F4 F5 F6 F7 F8 ...
</em><br />
<em class="quotelev1">&gt;
</em><br />
<br />So GEN, as you said, could be implemented as a program that generates
<br />
all possible character sequences and filters out the valid fortran
<br />
programs.  Perhaps it would do that by running each character sequence
<br />
through a fortran compiler (which would be included as part of GEN) and
<br />
sees which ones don't end up with a fatal compilation error.  I will
<br />
call this GENfilter, for reasons below.
<br />
<br />begin GENfilter
<br />
&nbsp;&nbsp;do for i = 1 to infinity
<br />
&nbsp;&nbsp;&nbsp;&nbsp;generate &quot;character sequence i&quot;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;run &quot;character sequence i&quot; through a fortran compiler
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if the result is valid
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output &quot;character sequence i&quot;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;else
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = i + 1
<br />
&nbsp;&nbsp;&nbsp;&nbsp;end if
<br />
&nbsp;&nbsp;end do
<br />
end GENfilter
<br />
<br /><em class="quotelev1">&gt; Note that GEN is not in the list {P1 P2 P3 P4 P5 P6 ...} for the non
</em><br />
<em class="quotelev1">&gt; interesting contingent fact that GEN is a 0 variable program.
</em><br />
<em class="quotelev1">&gt; But GEN2, defined by GEN2(n) = the code of the nth program in the list,
</em><br />
<em class="quotelev1">&gt; belongs to the list, given that GEN2 is a one variable program. So
</em><br />
<em class="quotelev1">&gt; GEN2(1) = P1,  GEN2(2) = P2, GEN2(3) = P3, etc.
</em><br />
<br />So if you had all of the programs GEN2(n) for n = 1 to infinity, could
<br />
you implement a GEN equivalent to GENfilter, which I will call GENcall
<br />
in the following manner?
<br />
<br />begin GENcall
<br />
&nbsp;&nbsp;do for n = 1 to infinity
<br />
&nbsp;&nbsp;&nbsp;&nbsp;call GEN2(n) and output its output (i.e. Pn)
<br />
&nbsp;&nbsp;end do
<br />
end GENcall
<br />
<br /><em class="quotelev1">&gt; And now, giving that GEN2 is in the list, there is a number k such that
</em><br />
<em class="quotelev1">&gt; GEN2 = Pk. Nothing magic here. True: GEN2(k) = Pk. Nothing paradoxical
</em><br />
<em class="quotelev1">&gt; here. GEN2 compute a total function, that is GEN2 on any n gives the
</em><br />
<em class="quotelev1">&gt; nth programs, and (diagonlaization), on its own indice k it gives its
</em><br />
<em class="quotelev1">&gt; own code Pk.
</em><br />
<br />OK.  Now I agree there's nothing magical about the generation part.
<br />
<br /><em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Now *your* G is just defined by G(n) = GEN2(n).
</em><br />
<br />But doesn't G output the range of one of the set of *all* partial
<br />
recursive functions, whereas GEN2 outputs the code of a *fortran*
<br />
program?  So shouldn't it be the following, where execute() actually
<br />
executes the fortran program generated by GEN2(n)?
<br />
<br />G(n) = execute(GEN2(n))
<br />
<br /><em class="quotelev1">&gt; It will use most
</em><br />
<em class="quotelev1">&gt; probably GEN as subroutine. I have already send to this list the code
</em><br />
<em class="quotelev1">&gt; of a GEN2 in LISP.
</em><br />
<br />I guess I was assuming that G would be implemented as the following,
<br />
similar to the method of GENcall, but as a one-variable program.  My G
<br />
would be
<br />
<br />begin G(n)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;call GEN2(n) and store its output in Pn
<br />
&nbsp;&nbsp;&nbsp;&nbsp;execute(Pn) and output its output
<br />
end G
<br />
<br />Perhaps this is where I am going astray.  I wondered why you kept
<br />
saying, in order to compute G(k), you have to generate *all* of the
<br />
programs for G(1) to G(k) (and then execute G(k)) , whereas if G is
<br />
defined as above, you would just call G with input k.  I guess in order
<br />
to have the code for GEN2(k) available to call, you would have to first
<br />
run GENfilter to find out which valid fortran program corresponds with
<br />
k, so you would end up generating all of the programs from 1 to k.
<br />
<br />Actually, it seems we could do this by writing GEN2 to use GEN's
<br />
&quot;filter&quot; method as follows:
<br />
<br />begin GEN2(n)
<br />
&nbsp;&nbsp;i = 1
<br />
&nbsp;&nbsp;do until i = n
<br />
&nbsp;&nbsp;&nbsp;&nbsp;generate &quot;character sequence i&quot;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;run &quot;character sequence i&quot; through a fortran compiler
<br />
&nbsp;&nbsp;&nbsp;&nbsp;if the result is valid
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output &quot;character sequence i&quot;
<br />
&nbsp;&nbsp;&nbsp;&nbsp;else
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = i + 1
<br />
&nbsp;&nbsp;&nbsp;&nbsp;end if
<br />
&nbsp;&nbsp;end do
<br />
end GEN2
<br />
<br />So then with GEN2 (with the filter method) and G programmed as above
<br />
(calling GEN2), if we go on to include *execution* of the code Pk
<br />
needed to compute G, then as I've said before, what will happen which
<br />
we execute G on k, if G=Pk?  When we &quot;execute(Pk)&quot; we literally will
<br />
execute the code for G (again, defined above).  This will call GEN2 to
<br />
generate the code for (all the programs P1 through) Pk, and then
<br />
*execute* Pk...  Hence, the infinite loop, without the &quot;+ 1&quot;, when you
<br />
consider *execution* of Pk, which is required in order to compute G.
<br />
<br /><em class="quotelev1">&gt; You can prove nothing with it. Like if an inhabitant of the Knight
</em><br />
<em class="quotelev1">&gt; Knave Island tell you &quot;I am a Knight&quot; It could be true (Knight always
</em><br />
<em class="quotelev1">&gt; tell the truth) or a lie (Knaves always lie).
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; *My* function G is defined by G(n) = GEN2(n) +1.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; And given that we have already program GEN2, it is a child play to
</em><br />
<em class="quotelev1">&gt; modify the program computing your G into mine: just add the instruction
</em><br />
<em class="quotelev1">&gt; &quot;+ 1&quot; at the right place.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Now, in case that G would be a total function, we would be in a
</em><br />
<em class="quotelev1">&gt; situation analog with what happens if you meet a inhabitant of the
</em><br />
<em class="quotelev1">&gt; Knight Knave Island saying &quot;I am a Knave&quot;, a total impossibility (if a
</em><br />
<em class="quotelev1">&gt; knave says it it would tell the truth which a knave never does, and a
</em><br />
<em class="quotelev1">&gt; Knight will never say the falsity &quot;I am a knave&quot;. It is the &quot;+ 1&quot; which
</em><br />
<em class="quotelev1">&gt; force the G function to be wrong in all case you give her its own
</em><br />
<em class="quotelev1">&gt; indice, as we have seen.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<br />I agree that if you add the &quot;+ 1&quot; then you can get a logical
<br />
diagonalization argument that says perhaps says something more than
<br />
without the &quot;+ 1&quot;.  I don't know yet what the &quot;more&quot; might be, because
<br />
I haven't yet convinced myself that there isn't an infinite loop (in
<br />
*execution*, not generation) without the &quot;+ 1&quot;.
<br />
<br /><em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev2">&gt; &gt; But if G = Fk, then when we go to explicitly write the
</em><br />
<em class="quotelev2">&gt; &gt; code for G, when we get to &quot;generate the code for Fk&quot; what to we write?
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; GEN generates all the codes. Like if I count 0, 1, 2, 3, .... without
</em><br />
<em class="quotelev1">&gt; ever stopping (in platonia) soon or later (actually later!) I will get
</em><br />
<em class="quotelev1">&gt; some of my correct Godel number describing me at the right level of
</em><br />
<em class="quotelev1">&gt; description. I will not be aware of that, but this is not the point.
</em><br />
<em class="quotelev1">&gt; GEN generates algorithmically, mechanically, &quot;fortranically&quot; all the
</em><br />
<em class="quotelev1">&gt; fortran codes. If you doubt this can be done, the best is that you
</em><br />
<em class="quotelev1">&gt; write the code for yourself.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<br />If we're talking just generation, then I agree there is no problem.
<br />
<br /><em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev2">&gt; &gt;  Fk *is* G. So we start generating G from the beginning until we again
</em><br />
<em class="quotelev2">&gt; &gt; get to the part &quot;generate the code for Fk&quot; and then we do this forever.
</em><br />
<em class="quotelev2">&gt; &gt;
</em><br />
<em class="quotelev2">&gt; &gt; It's sort of like at dinner when I ask my son or daughter what they did
</em><br />
<em class="quotelev2">&gt; &gt; today, and they tell me everything they did starting with &quot;I woke up
</em><br />
<em class="quotelev2">&gt; &gt; and made my bed...&quot;, and jokingly they finally say, &quot;...and then sat
</em><br />
<em class="quotelev2">&gt; &gt; down for dinner and told you, 'I woke up and made my bed...' ...&quot;  But
</em><br />
<em class="quotelev2">&gt; &gt; of course they finally stop and laugh, instead of going forever.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Something similar happens with the universal dovetailing. But here we
</em><br />
<em class="quotelev1">&gt; use just the program generating part of the dovetailing. Your G as
</em><br />
<em class="quotelev1">&gt; mine, applied to n, does compute directly, without dovetailing the
</em><br />
<em class="quotelev1">&gt; value Fn(n) or Fn(n)+1 (cf Fn is the function computed by the program
</em><br />
<em class="quotelev1">&gt; Pn).
</em><br />
<em class="quotelev1">&gt;
</em><br />
<br />So you are saying that we are doing just the generation part.  But in
<br />
order to talk about what values of n that G is defined on, don't we
<br />
have to talk about which values of n that G crashes (runs forever) on
<br />
when it is *executed*?
<br />
<br />I'm wondering if perhaps an &quot;essential&quot; diagonalization is happening
<br />
even in self-reference, whether with in the dinner-table situation or
<br />
with G(k)=Fk(k).  Perhaps it is because when someone says, &quot;I told
<br />
you...&quot;, the &quot;I&quot; that is saying &quot;I told you&quot; is a *different* &quot;I&quot; from
<br />
the &quot;I&quot; that &quot;told you&quot;.  Likewise the G that is called the first time
<br />
is a *different* G from the G that is called the second time...  Yes,
<br />
they have the same code, but the first G is the &quot;first G&quot;, whereas the
<br />
second G is the &quot;second G&quot;, if you understand what I mean.  Perhaps
<br />
this is doing something that is similar to the (classical
<br />
diagonalization) *forcing* the G's to be even more different by
<br />
changing their outputs by &quot;+ 1&quot;.
<br />
<br /><em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev2">&gt; &gt;
</em><br />
<em class="quotelev2">&gt; &gt; This is where I'm stumped.  You say that we escape the diagonalization
</em><br />
<em class="quotelev2">&gt; &gt; and the program runs forever (because 0 is not equal to 1).  I'm trying
</em><br />
<em class="quotelev2">&gt; &gt; to get a firm handle on what is actually going on here.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; You are right to do so. Understanding the (effective, programmable)
</em><br />
<em class="quotelev1">&gt; diagonalization of the Fi, is needed to proceed. It shows that IF
</em><br />
<em class="quotelev1">&gt; Church thesis is correct so that the Fi contains all the total
</em><br />
<em class="quotelev1">&gt; computable functions (that is the Pi contains all the codes of the
</em><br />
<em class="quotelev1">&gt; total computable functions) THEN the code of the total function is
</em><br />
<em class="quotelev1">&gt; necessarily HIDDEN in the Fi. No algorithmic procedure capable of
</em><br />
<em class="quotelev1">&gt; distinuishing the Pi computing total comp. function from the Pi
</em><br />
<em class="quotelev1">&gt; computing the proper partial one will ever exist. As I shown this shows
</em><br />
<em class="quotelev1">&gt; quickly both insolubility and incompleteness.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev2">&gt; &gt; Is there some
</em><br />
<em class="quotelev2">&gt; &gt; intuitive definition that is causing an ambiguity, just like the
</em><br />
<em class="quotelev2">&gt; &gt; definition of a function itself, as in my previous post?
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; I don't think there is anything conceptually ambiguous once you accept
</em><br />
<em class="quotelev1">&gt; CT. What has been  proved to be necessarily mathematically ambiguous is
</em><br />
<em class="quotelev1">&gt; the notion of total computable function; in the sense that we have
</em><br />
<em class="quotelev1">&gt; prove that NO algorithm can test in general the totality or proper
</em><br />
<em class="quotelev1">&gt; partiality of the function computed by some code.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; This is gives us two path in the conquest of the &quot;controllable world&quot;.
</em><br />
<em class="quotelev1">&gt; Either from inside by augmenting in the constructive transfinite RE
</em><br />
<em class="quotelev1">&gt; *subset* of the set of codes for total functions. This is mainly the
</em><br />
<em class="quotelev1">&gt; path toward the first person plenitude; or by accepting the jump toward
</em><br />
<em class="quotelev1">&gt; the partial functions and learning to live together with a partially
</em><br />
<em class="quotelev1">&gt; non controllable reality. It is akin to the third person jump of act of
</em><br />
<em class="quotelev1">&gt; faith, but it is also the openness toward the others (which you cannot
</em><br />
<em class="quotelev1">&gt; control).
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Tell me if you are convince that &quot;your&quot; and &quot;my&quot; G are programmable.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<br />They are both programmable, but I think they are both non-*executable*
<br />
on &quot;k&quot; (if G=Fk), for the same reason, self-reference.
<br />
<br /><em class="quotelev1">&gt; You would be kind to tell me if you understand my preceding posts after
</em><br />
<em class="quotelev1">&gt; getting that G is programmable. (I thought you already get that GEN was
</em><br />
<em class="quotelev1">&gt; programmable). You should understand that I have proved rigorously
</em><br />
<em class="quotelev1">&gt; (thanks to CT) the incompleteness of computer science. To prove the
</em><br />
<em class="quotelev1">&gt; incompleteness of arithmetic/number theory from that consists only in
</em><br />
<em class="quotelev1">&gt; showing that enough of computer science can be translated in number
</em><br />
<em class="quotelev1">&gt; theory to inherit essential incompleteness. One path is Godel's
</em><br />
<em class="quotelev1">&gt; arithmetization, another one, quite beautiful, is the study of the
</em><br />
<em class="quotelev1">&gt; Diophantine equations, the work of Matiyasevich(*) ... (RE set can be
</em><br />
<em class="quotelev1">&gt; characterized by Diophantine sets of numbers. Diophantus is a
</em><br />
<em class="quotelev1">&gt; contemporary to Plotinus, about 200-300 after JC).
</em><br />
<em class="quotelev1">&gt; This is needed to understand how the many computational histories are
</em><br />
<em class="quotelev1">&gt; implemented in all possible sort of ways in the realm of numbers, and
</em><br />
<em class="quotelev1">&gt; later how they interfere when seen from inside, and how from inside
</em><br />
<em class="quotelev1">&gt; (from 1 povs) all plotinus hypostases get arithmetical interpretations,
</em><br />
<em class="quotelev1">&gt; including the one describing &quot;matter&quot;, which we can then be compared to
</em><br />
<em class="quotelev1">&gt; the empirical quantum, to test the comp hypothesis. OK?
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Bruno
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; (*) Yuri V. Matiyasevich (foreword by Martin Davis), Third printing
</em><br />
<em class="quotelev1">&gt; 1996, Hilbert's Tenth Problem, The MIT Press (1993 Russian Edition).
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; <a href="http://iridia.ulb.ac.be/~marchal/">http://iridia.ulb.ac.be/~marchal/</a>
</em><br />
<br /><br />--~--~---------~--~----~------------~-------~--~----~
<br />
You received this message because you are subscribed to the Google Groups &quot;Everything List&quot; group.
<br />
To post to this group, send email to everything-list.domain.name.hidden
<br />
To unsubscribe from this group, send email to everything-list-unsubscribe.domain.name.hidden
<br />
For more options, visit this group at <a href="http://groups.google.com/group/everything-list">http://groups.google.com/group/everything-list</a>
<br />
-~----------~----~----~----~------~----~------~--~---
<br />
<span id="received"><dfn>Received on</dfn> Mon Jul 17 2006 - 16:43:16 PDT</span>
</div>
<!-- body="end" -->
<div class="foot">
<map id="navbarfoot" name="navbarfoot" title="Related messages">
<ul class="links">
<li><dfn>This message</dfn>: [ <a href="#start9938">Message body</a> ]</li>
<!-- lnext="start" -->
<li><dfn>Next message</dfn>: <a href="9939.html" title="Next message in the list">1Z: "Re: SV: Only Existence is necessary?"</a></li>
<li><dfn>Previous message</dfn>: <a href="9937.html" title="Previous message in the list">1Z: "Re: SV: Only Existence is necessary?"</a></li>
<li><dfn>In reply to</dfn>: <a href="9921.html" title="Message to which this message replies">Bruno Marchal: "Re: Diagonalization (solution-sequel)"</a></li>
<!-- lnextthread="start" -->
<li><dfn>Next in thread</dfn>: <a href="9941.html" title="Next message in this discussion thread">Tom Caylor: "Re: Diagonalization (solution-sequel)"</a></li>
<li><a name="replies" id="replies"></a>
<dfn>Reply</dfn>: <a href="9941.html" title="Message sent in reply to this message">Tom Caylor: "Re: Diagonalization (solution-sequel)"</a></li>
<li><dfn>Reply</dfn>: <a href="9943.html" title="Message sent in reply to this message">Bruno Marchal: "K the Master Set (+ partial answer to Tom&#0039;s Diagonalization)"</a></li>
<!-- lreply="end" -->
</ul>
<ul class="links">
<li><a name="options3" id="options3"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg9938" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg9938" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg9938" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg9938" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</map>
</div>
<!-- trailer="footer" -->
<p><small><em>
This archive was generated by <a href="http://www.hypermail-project.org/">hypermail 2.3.0</a>
: Fri Feb 16 2018 - 13:20:11 PST
</em></small></p>
</body>
</html>
