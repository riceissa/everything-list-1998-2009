<?xml version="1.0" encoding="us-ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="generator" content="hypermail 2.3.0, see http://www.hypermail-project.org/" />
<title>Re: Questions on Russell's &quot;Why Occam&quot; paper from Russell Standish on 2005-06-05 (everything)</title>
<meta name="Author" content="Russell Standish (r.standish.domain.name.hidden)" />
<meta name="Subject" content="Re: Questions on Russell's &quot;Why Occam&quot; paper" />
<meta name="Date" content="2005-06-05" />
<style type="text/css">
/*<![CDATA[*/
/* To be incorporated in the main stylesheet, don't code it in hypermail! */
body {color: black; background: #ffffff}
dfn {font-weight: bold;}
pre { background-color:inherit;}
.head { border-bottom:1px solid black;}
.foot { border-top:1px solid black;}
th {font-style:italic;}
table { margin-left:2em;}map ul {list-style:none;}
#mid { font-size:0.9em;}
#received { float:right;}
address { font-style:inherit ;}
/*]]>*/
.quotelev1 {color : #990099}
.quotelev2 {color : #ff7700}
.quotelev3 {color : #007799}
.quotelev4 {color : #95c500}
.period {font-weight: bold}
</style>
</head>
<body>
<div class="head">
<h1>Re: Questions on Russell's &quot;Why Occam&quot; paper</h1>
<!-- received="Sun Jun  5 21:42:20 2005" -->
<!-- isoreceived="20050606044220" -->
<!-- sent="Mon, 6 Jun 2005 10:21:15 +1000" -->
<!-- isosent="20050606002115" -->
<!-- name="Russell Standish" -->
<!-- email="r.standish.domain.name.hidden" -->
<!-- subject="Re: Questions on Russell's &quot;Why Occam&quot; paper" -->
<!-- id="20050606002115.GA348.domain.name.hidden" -->
<!-- charset="us-ascii" -->
<!-- inreplyto="20050603232207.DF37557E8C.domain.name.hidden" -->
<!-- expires="-1" -->
<map id="navbar" name="navbar">
<ul class="links">
<li>
<dfn>This message</dfn>:
[ <a href="#start6914" name="options1" id="options1" tabindex="1">Message body</a> ]
 [ More options (<a href="#options2">top</a>, <a href="#options3">bottom</a>) ]
</li>
<li>
<dfn>Related messages</dfn>:
<!-- unext="start" -->
[ <a href="6915.html" accesskey="d" title="Stathis Papaioannou: &quot;RE: Another Tedious Hypothetical&quot;">Next message</a> ]
[ <a href="6913.html" title="Lee Corbin: &quot;RE: Another tedious hypothetical&quot;">Previous message</a> ]
[ <a href="6884.html" title="Hal Finney: &quot;Questions on Russell&#0039;s &#0034;Why Occam&#0034; paper&quot;">In reply to</a> ]
<!-- unextthread="start" -->
[ <a href="6936.html" accesskey="t" title="Patrick Leahy: &quot;Re: Questions on Russell&#0039;s &#0034;Why Occam&#0034; paper&quot;">Next in thread</a> ]
 [ <a href="#replies">Replies</a> ]
<!-- ureply="end" -->
</li>
</ul>
</map>
<ul class="links">
<li><a name="options2" id="options2"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg6914" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg6914" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg6914" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg6914" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</div>
<!-- body="start" -->
<div class="mail">
<address class="headers">
<span id="from">
<dfn>From</dfn>: Russell Standish &lt;<a href="mailto:r.standish.domain.name.hidden?Subject=Re%3A%20Questions%20on%20Russell's%20%22Why%20Occam%22%20paper">r.standish.domain.name.hidden</a>&gt;
</span><br />
<span id="date"><dfn>Date</dfn>: Mon, 6 Jun 2005 10:21:15 +1000</span><br />
</address>
<br />
On Fri, Jun 03, 2005 at 04:22:07PM -0700, &quot;Hal Finney&quot; wrote:
<br />
<em class="quotelev1">&gt; Russell Standish recently mentioned his paper &quot;Why Occam's Razor&quot; which
</em><br />
<em class="quotelev1">&gt; can be found at <a href="http://parallel.hpc.unsw.edu.au/rks/docs/occam/">http://parallel.hpc.unsw.edu.au/rks/docs/occam/</a> .  Among
</em><br />
<em class="quotelev1">&gt; other things he aims to derive quantum mechanics from a Schmidhuber type
</em><br />
<em class="quotelev1">&gt; ensemble.  I have tried to read this paper but never really understood it.
</em><br />
<em class="quotelev1">&gt; Here I will try to ask some questions, taking it slowly.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; On this page, <a href="http://parallel.hpc.unsw.edu.au/rks/docs/occam/node2.html">http://parallel.hpc.unsw.edu.au/rks/docs/occam/node2.html</a> ,
</em><br />
<em class="quotelev1">&gt; things get started.  Russell describes a set of infinite bit strings he
</em><br />
<em class="quotelev1">&gt; calls &quot;descriptions&quot;.  He writes:
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; &quot;By contrast to Schmidhuber, I assume a uniform measure over these
</em><br />
<em class="quotelev1">&gt; descriptions -- no particular string is more likely than any other.&quot;
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; This surprises me.  I thought that Schmidhuber assumed a uniform measure
</em><br />
<em class="quotelev1">&gt; over bit strings considered as programs for his universal computer.  So
</em><br />
<em class="quotelev1">&gt; what is the &quot;contrast&quot; to his work?
</em><br />
<br />Nowhere in Schmidhuber (1997) does he propose a measure over the &quot;input
<br />
programs&quot;. What he does is is justify the appearance of a universal
<br />
prior in the set of descriptions by passing the raw data through a
<br />
reference UTM. Presumably the set of descriptions is sampled uniformly
<br />
by the observer.
<br />
<br />In Schmidhuber (2000), the set of descriptions is generated by a
<br />
machine which has resource bounds. This leads to the notion of &quot;speed
<br />
prior&quot; which differs from the universal prior in several important
<br />
respects. I sometimes refer to the two different ensembles as
<br />
Schmidhuber I and Schmidhuber II.
<br />
<br />I am beginning to regret calling the all descriptions ensemble with
<br />
uniform measure a Schmidhuber ensemble. I think what I meant was that
<br />
it could be generated by a standard dovetailer algorithm, running for
<br />
2^\aleph_0 timesteps. However, as the cardinality of &quot;my&quot; ensemble is
<br />
actually &quot;c&quot; (cardinality of the real numbers), it is quite probably a
<br />
completely different beast. It is also not generated by a program,
<br />
Schmidhuber style, it simply is (in the sense of being the simplest
<br />
set - equivalent to nothing).
<br />
<br /><em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; It seems that the greater contrast is that while Schmidhuber assumed that
</em><br />
<em class="quotelev1">&gt; the bit strings would be fed into a computer that would produce outputs,
</em><br />
<em class="quotelev1">&gt; Russell is taking the bit strings directly as raw data.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />Quite true.
<br />
<br /><br /><em class="quotelev1">&gt; But I am confused about their role.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; &quot;Since some of these descriptions describe self aware substructures...&quot;
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; Whoa!  This is a big leap for me.  First, I am not too happy that mere bit
</em><br />
<em class="quotelev1">&gt; strings have been elevated with the title &quot;descriptions&quot;.  A bit string on
</em><br />
<em class="quotelev1">&gt; its own doesn't seem to have the inherent meaning necessary for it to be
</em><br />
<em class="quotelev1">&gt; considered a description.  
</em><br />
<br />Many apologies for deploying terminology in a different way to you
<br />
expect. A description (in my terminology) does not necessarily have
<br />
meaning. It is simply data. This is in accord with how I use the term
<br />
in casual English usage too - a description is simply a string of
<br />
letters, and may or may not be meaningful. Meaning is attached by an observer.
<br />
<br />Now an observer will expect to find a SAS in one of the descriptions
<br />
as a corrolory of the anthropic principle, which is explicitly stated
<br />
as one of the assumptions in this work. I make no bones about this - I
<br />
consider the anthropic principle a mystery, not self-evident like
<br />
many people. Why should an observer expect to see a token of erself
<br />
embedded in reality? That is the mystery of the AP.
<br />
<br /><em class="quotelev1">&gt; And now we find not only that the bit string is
</em><br />
<em class="quotelev1">&gt; a description, but it is a complex enough description to describe SAS's?
</em><br />
<em class="quotelev1">&gt; How does that work?
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />The bitstrings are infinite in length. By reading enough bits, they can
<br />
have arbitrarily complex meanings attached to them.
<br />
<br /><em class="quotelev1">&gt; It's especially confusing to read the introductory word &quot;since&quot; as though
</em><br />
<em class="quotelev1">&gt; this is all quite obvious and need not be explained.  To me it is very
</em><br />
<em class="quotelev1">&gt; confusing.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />Sorry for not going slow enough. The habits of concise expression are
<br />
hard to shake.
<br />
<br /><em class="quotelev1">&gt; The page goes on to identify these SAS's as observers.  Now they are mappings,
</em><br />
<em class="quotelev1">&gt; or equivalently Turing Machines, which map finite bit strings to integers.
</em><br />
<em class="quotelev1">&gt; These integers are the &quot;meanings&quot; of the bit strings.
</em><br />
<br />Not equivalently. Not all maps can be represented by a Turing machine,
<br />
only computable ones.
<br />
<br /><em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; I believe the idea here is that the bit strings are taken as prefixes
</em><br />
<em class="quotelev1">&gt; of the &quot;description&quot; bit strings in the ensemble.  It is as though the
</em><br />
<em class="quotelev1">&gt; &quot;observers&quot; are observing the &quot;descriptions&quot; a bit at a time, and mapping
</em><br />
<em class="quotelev1">&gt; them to a sequence of integer &quot;meanings&quot;.  Is that correct?
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />Indeed that is one interpretation. The most important point is that
<br />
the observer map is a &quot;prefix&quot; map, in the sense of prefix machines of
<br />
Algorithmic Information Theory. In reading a bit string one bit at a
<br />
time, once a meaning is attached to the string, that is the meaning
<br />
for evermore - the observer cannot change er mind after reading a few
<br />
more bits.
<br />
<br />Schmidhuber (2000) deals with machines that do &quot;change their mind&quot;, so
<br />
perhaps there is some extension possible in this direction.
<br />
<br /><em class="quotelev1">&gt; So here is another confusion about the role of the &quot;description&quot; bit
</em><br />
<em class="quotelev1">&gt; strings in the model.  Are they things that &quot;observer&quot; TM's observe and
</em><br />
<em class="quotelev1">&gt; map to integers?  Or are they places where observers live, as suggested
</em><br />
<em class="quotelev1">&gt; by the &quot;Since&quot; line quoted above?  Or both?
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />All that is discussed in this paper is appearances - we only try to
<br />
explain the phenomenon (things as they appear). No attempt is made to
<br />
explain the noumenon (things as they are), nor do we need to assume
<br />
that there is a noumenon. Bruno Marchal has a detailed discussion on
<br />
this in his thesis, and concludes that he &quot;has no need for this
<br />
hypothesis&quot; (what he calls the extravagant hypothesis).
<br />
<br />So the former statement is true : things that &quot;observer&quot; TM's observe and
<br />
map to integers. It is also true that descriptions of self aware
<br />
observers will appear within the description by the Anthropic
<br />
Principle. The phenomenon of observerhood is included. However where
<br />
the observers actually live is not a meaningful question in this framework.
<br />
<br /><em class="quotelev1">&gt; Now it gets a little more complicated: &quot;Under the mapping O(x), some
</em><br />
<em class="quotelev1">&gt; descriptions encode for identical meanings as other descriptions, so
</em><br />
<em class="quotelev1">&gt; one should equivalence class the descriptions.&quot;
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; The problem I have is, O takes only finite bit strings. 
</em><br />
<br />Only a finite number of bits are significant. They still operate on
<br />
infinite bitstrings.
<br />
<br /><em class="quotelev1">&gt; So technically
</em><br />
<em class="quotelev1">&gt; a &quot;description&quot;, which is an infinite bit string, does not encode a
</em><br />
<em class="quotelev1">&gt; meaning. 
</em><br />
<br />Yes.
<br />
<br /><em class="quotelev1">&gt; What I think is meant here, though, is that two &quot;descriptions&quot;
</em><br />
<em class="quotelev1">&gt; (i.e. infinite bit strings) will be considered equivalent if for every
</em><br />
<em class="quotelev1">&gt; finite prefix of the strings, the O() mapping is the same. 
</em><br />
<br />Yes
<br />
<br /><em class="quotelev1">&gt;  So if we
</em><br />
<em class="quotelev1">&gt; think of O as &quot;observing&quot; the &quot;description&quot; bit strings one by one,
</em><br />
<em class="quotelev1">&gt; it will go through precisely the same sequence of integer &quot;meanings&quot;
</em><br />
<em class="quotelev1">&gt; in each case.  Is that right?
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />I think you're saying that O(x) has unique value for any given value
<br />
of x. In which case you're right.
<br />
<br /><em class="quotelev1">&gt; &quot;In particular, strings where the bits after some bit number n are
</em><br />
<em class="quotelev1">&gt; ``don't care'' bits, are in fact equivalence classes of all strings that
</em><br />
<em class="quotelev1">&gt; share the first n bits in common.&quot;
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />Sets of strings corresponding to a given meaning are an equivalence
<br />
class of descriptions, yes.
<br />
<br /><em class="quotelev1">&gt; I think what this considers is a special O() and a special string prefix
</em><br />
<em class="quotelev1">&gt; such that if O sees that particular n-bit prefix, all extensions of
</em><br />
<em class="quotelev1">&gt; that prefix get mapped to the same &quot;meaning&quot; integer.  In that case the
</em><br />
<em class="quotelev1">&gt; condition described in my previous paragraph would be met, and all
</em><br />
<em class="quotelev1">&gt; strings with this n-bit prefix would be equivalent.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />yes. This is the condition that O(x) is a prefix map.
<br />
<br /><em class="quotelev1">&gt; &quot;One can see that the size of the equivalence class drops off
</em><br />
<em class="quotelev1">&gt; exponentially with the amount of information encoded by the string.&quot;
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; That seems a little questionable because the size of the equivalence class
</em><br />
<em class="quotelev1">&gt; is infinite in all cases.  However I think Russell means to use a uniform
</em><br />
<em class="quotelev1">&gt; measure where the collection of all strings with a particular n-bit
</em><br />
<em class="quotelev1">&gt; prefix have a measure of 1/2^n.  It's not clear how well this measure
</em><br />
<em class="quotelev1">&gt; really works or whether it applies to all sets of infinite strings.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />Maybe I'm being sloppy. Size here means measure, not cardinality. I
<br />
can appreciate your confusion.
<br />
<br />The uniform measure works, because the set of all descriptions is
<br />
one-to-one mappable to the real interval [0,1], except for a set of
<br />
points of measure zero (rational numbers with power of 2 denominators)
<br />
where 2 descriptions map to the same real number.
<br />
<br />Just as the uniform measure works with the reals (and allows integral
<br />
calculus to work), the uniform measure works with descriptions. The
<br />
measure of equivalence classes O^{-1}(n) also follows in a straight
<br />
forward fashion from the uniform measure.
<br />
<br /><em class="quotelev1">&gt; &quot;Under O(x), the amount of information is not necessarily equal to the
</em><br />
<em class="quotelev1">&gt; length of the string, as some of the bits may be redundant.&quot;
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; Now we have this new concept of &quot;the amount of information&quot; which has
</em><br />
<em class="quotelev1">&gt; not previously been defined.  This sentence is really hard for me.
</em><br />
<em class="quotelev1">&gt; What does it mean for bits to be redundant?  
</em><br />
<br />This sentence is part of the hand-waving &quot;furniture&quot; - its meant to
<br />
make things easier for the reader, not harder. Most people have an
<br />
intuitive notion of what redundancy means. Please ignore it if it
<br />
makes you feel better.
<br />
<br />Later on I do define amount of information, or complexity to use its
<br />
proper name as {\cal C}_O(x) = -\log_2 P_O(O(x)), and appeal to the
<br />
coding theorem as a way of relating it to Kolmogorov complexity K(x).
<br />
<br /><em class="quotelev1">&gt; We just discussed strings
</em><br />
<em class="quotelev1">&gt; where all those after bit n are &quot;don't care&quot;, but this sentence seems
</em><br />
<em class="quotelev1">&gt; to be envisioning other kinds of redundancies.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />Indeed.
<br />
<br /><em class="quotelev1">&gt; &quot;The sum P_O(s) = [sum over p such that O(p)=s of] 2^(-|p|)
</em><br />
<em class="quotelev1">&gt; where |p| means the number of bits of p consumed by O in returning s,
</em><br />
<em class="quotelev1">&gt; gives the size of the equivalence class of all descriptions having
</em><br />
<em class="quotelev1">&gt; meaning s.&quot;
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; Boy, that's a tough one now.  We consider all bit strings p such that O(p)
</em><br />
<em class="quotelev1">&gt; = s.  Now, is this supposed to just be those cases described earlier where
</em><br />
<em class="quotelev1">&gt; the bits after |p| are &quot;don't care&quot; bits?  Or is it all strings p such
</em><br />
<em class="quotelev1">&gt; that O(p) = s, including all extensions of a string where we &quot;don't care&quot;
</em><br />
<em class="quotelev1">&gt; after some point?  If the latter, it seems problematical because there
</em><br />
<em class="quotelev1">&gt; would be an uncountably infinite number of such p's.  Also I think the sum
</em><br />
<em class="quotelev1">&gt; would not converge in that case.  So I think it is probably the former.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />You have indeed hoisted me here. Well done! Of course the mistake is
<br />
not really serious, and can be patched up by taking the former
<br />
meaning you suggest, or merely to note that the measure of the set
<br />
with with common prefix of length |p| is precisely 2^{-|p|}, and then
<br />
the sum is over all such subsets of descriptions.
<br />
<br /><em class="quotelev1">&gt; But then, what if there is a string p such that O(p)=s, but if we append
</em><br />
<em class="quotelev1">&gt; anything to p, either p+0 or p+1, then O of those strings is not s?
</em><br />
<em class="quotelev1">&gt; Does that p add to the equivalence class or not?
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />Remember O(x) is a prefix map. That cannot happen.
<br />
<br /><em class="quotelev1">&gt; And is it the case that for all O and for every &quot;description&quot; bit string,
</em><br />
<em class="quotelev1">&gt; there will be some prefix beyond which all the bits are &quot;don't care&quot;?
</em><br />
<em class="quotelev1">&gt; Would that follow from the finiteness of O?  If not, how do these
</em><br />
<em class="quotelev1">&gt; &quot;descriptions&quot; feed into the measure?
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />If there are no &quot;don't care&quot; bits, the description contributes zero
<br />
measure. This is not a problem, so long as there is at least one class
<br />
of strings with don't care bits.
<br />
<br /><em class="quotelev1">&gt; And I'm a little concerned about the appearance of 2^(-|p|) here without
</em><br />
<em class="quotelev1">&gt; much motivation.
</em><br />
<br />Perhaps making the summation index p run over subsets rather than
<br />
descriptions would help here, as I men tioned above. The subsets
<br />
correpond to finite length bitstrings (the &quot;prefix&quot;), and the |p|
<br />
corresponds to the length of that prefix.
<br />
<br /><em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; &quot;The quantity C_O(x) = - log2( P_O( O(x) ) )
</em><br />
<em class="quotelev1">&gt; is a measure of the information content, or complexity of a description x.&quot;
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; Now I am becoming confused about whether O() is supposed to apply
</em><br />
<em class="quotelev1">&gt; to the infinite bit strings that are &quot;descriptions&quot; or only to their
</em><br />
<em class="quotelev1">&gt; finite prefixes.  I thought it was the latter.  I don't see how a TM
</em><br />
<em class="quotelev1">&gt; can come up with a meaningful value on an infinite bit string.  It can
</em><br />
<em class="quotelev1">&gt; never read in the whole input if it is infinite in size.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />It does not need to. 
<br />
<br /><br /><em class="quotelev1">&gt; &quot;If only the first n bits of the string are significant, with no
</em><br />
<em class="quotelev1">&gt; redundancy, then it is easy to see C_O(x)=n.&quot;
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; That part does make sense, if in fact the definition of P_O(s) was
</em><br />
<em class="quotelev1">&gt; only with reference to &quot;description&quot; strings which were &quot;don't care&quot;
</em><br />
<em class="quotelev1">&gt; after some number of bits.  And I think the part about &quot;no redundancy&quot;
</em><br />
<em class="quotelev1">&gt; means there are no other bit string prefixes which O maps to the same
</em><br />
<em class="quotelev1">&gt; value as it maps the n-bit prefix of x.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; The page then goes on to make some comments about measure applied to
</em><br />
<em class="quotelev1">&gt; universes.  Here again I am confused about how to relate it to all that
</em><br />
<em class="quotelev1">&gt; has been descibed.  What are the analogs of universes, in this model?
</em><br />
<em class="quotelev1">&gt; Is it &quot;descriptions&quot;, the infinite bit strings?  From what has been
</em><br />
<em class="quotelev1">&gt; presented so far, I don't understand how to relate our experience of
</em><br />
<em class="quotelev1">&gt; reality to this model.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<br />Each description is a possible universe, composed of an infinite
<br />
amount of information. Any observer will of course only comprehend a
<br />
finite amount information, and hence be in a superposition of a subset
<br />
of universes corresponding to that finite information. Admittedly the
<br />
usage of the term &quot;universe&quot; is slightly strange here.
<br />
<br />Alterantively, one could talk about &quot;observer moments&quot; as
<br />
corresponding to the equivalence classes of descriptions. This
<br />
interpretation would be more natural to many here on this list. 
<br />
<br />In section 3 of the paper, I now introduce a temporal dimension, with
<br />
the observer repeatedly sampling the set of all descriptions, with the
<br />
proviso that successor states can only differ by a finite number of bits.
<br />
<br /><em class="quotelev1">&gt; That's it for the first page.  Hopefully these questions will help to
</em><br />
<em class="quotelev1">&gt; show where I am getting confused.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; Hal Finney
</em><br />
<br />Cheers
<br />
<br /><pre>
-- 
*PS: A number of people ask me about the attachment to my email, which
is of type &quot;application/pgp-signature&quot;. Don't worry, it is not a
virus. It is an electronic signature, that may be used to verify this
email came from me if you have PGP or GPG installed. Otherwise, you
may safely ignore this attachment.
----------------------------------------------------------------------------
A/Prof Russell Standish                  Phone 8308 3119 (mobile)
Mathematics                         	       0425 253119 (&quot;)
UNSW SYDNEY 2052         	         R.Standish.domain.name.hidden             
Australia                                <a href="http://parallel.hpc.unsw.edu.au/rks">http://parallel.hpc.unsw.edu.au/rks</a>
            International prefix  +612, Interstate prefix 02
----------------------------------------------------------------------------

</pre>
<br />
<br /><div>
<ul>
<li>application/pgp-signature attachment: <a href="att-6914/01-part">stored</a></li>
</ul>
<!-- attachment="01-part" -->
</div>
<span id="received"><dfn>Received on</dfn> Sun Jun 05 2005 - 21:42:20 PDT</span>
</div>
<!-- body="end" -->
<div class="foot">
<map id="navbarfoot" name="navbarfoot" title="Related messages">
<ul class="links">
<li><dfn>This message</dfn>: [ <a href="#start6914">Message body</a> ]</li>
<!-- lnext="start" -->
<li><dfn>Next message</dfn>: <a href="6915.html" title="Next message in the list">Stathis Papaioannou: "RE: Another Tedious Hypothetical"</a></li>
<li><dfn>Previous message</dfn>: <a href="6913.html" title="Previous message in the list">Lee Corbin: "RE: Another tedious hypothetical"</a></li>
<li><dfn>In reply to</dfn>: <a href="6884.html" title="Message to which this message replies">Hal Finney: "Questions on Russell&#0039;s &#0034;Why Occam&#0034; paper"</a></li>
<!-- lnextthread="start" -->
<li><dfn>Next in thread</dfn>: <a href="6936.html" title="Next message in this discussion thread">Patrick Leahy: "Re: Questions on Russell&#0039;s &#0034;Why Occam&#0034; paper"</a></li>
<li><a name="replies" id="replies"></a>
<dfn>Reply</dfn>: <a href="6936.html" title="Message sent in reply to this message">Patrick Leahy: "Re: Questions on Russell&#0039;s &#0034;Why Occam&#0034; paper"</a></li>
<!-- lreply="end" -->
</ul>
<ul class="links">
<li><a name="options3" id="options3"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg6914" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg6914" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg6914" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg6914" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</map>
</div>
<!-- trailer="footer" -->
<p><small><em>
This archive was generated by <a href="http://www.hypermail-project.org/">hypermail 2.3.0</a>
: Fri Feb 16 2018 - 13:20:10 PST
</em></small></p>
</body>
</html>
