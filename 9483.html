<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
<meta name="generator" content="hypermail 2.3.0, see http://www.hypermail-project.org/" />
<title>Re: *THE* PUZZLE (was: ascension, Smullyan, ...) from Tom Caylor on 2006-06-10 (everything)</title>
<meta name="Author" content="Tom Caylor (Daddycaylor.domain.name.hidden)" />
<meta name="Subject" content="Re: *THE* PUZZLE (was: ascension, Smullyan, ...)" />
<meta name="Date" content="2006-06-10" />
<style type="text/css">
/*<![CDATA[*/
/* To be incorporated in the main stylesheet, don't code it in hypermail! */
body {color: black; background: #ffffff}
dfn {font-weight: bold;}
pre { background-color:inherit;}
.head { border-bottom:1px solid black;}
.foot { border-top:1px solid black;}
th {font-style:italic;}
table { margin-left:2em;}map ul {list-style:none;}
#mid { font-size:0.9em;}
#received { float:right;}
address { font-style:inherit ;}
/*]]>*/
.quotelev1 {color : #990099}
.quotelev2 {color : #ff7700}
.quotelev3 {color : #007799}
.quotelev4 {color : #95c500}
.period {font-weight: bold}
</style>
</head>
<body>
<div class="head">
<h1>Re: *THE* PUZZLE (was: ascension, Smullyan, ...)</h1>
<!-- received="Sat Jun 10 20:01:51 2006" -->
<!-- isoreceived="20060611030151" -->
<!-- sent="Sat, 10 Jun 2006 17:00:50 -0700" -->
<!-- isosent="20060611000050" -->
<!-- name="Tom Caylor" -->
<!-- email="Daddycaylor.domain.name.hidden" -->
<!-- subject="Re: *THE* PUZZLE (was: ascension, Smullyan, ...)" -->
<!-- id="1149984050.255285.150230.domain.name.hidden" -->
<!-- charset="US-ASCII" -->
<!-- inreplyto="34fe134557c69700aeb5a654ab15da5e.domain.name.hidden" -->
<!-- expires="-1" -->
<map id="navbar" name="navbar">
<ul class="links">
<li>
<dfn>This message</dfn>:
[ <a href="#start9483" name="options1" id="options1" tabindex="1">Message body</a> ]
 [ More options (<a href="#options2">top</a>, <a href="#options3">bottom</a>) ]
</li>
<li>
<dfn>Related messages</dfn>:
<!-- unext="start" -->
[ <a href="9484.html" accesskey="d" title="Tom Caylor: &quot;Re: *THE* PUZZLE (was: ascension, Smullyan, ...)&quot;">Next message</a> ]
[ <a href="9482.html" title="Bruno Marchal: &quot;Re: *THE* PUZZLE (was: ascension, Smullyan, ...)&quot;">Previous message</a> ]
[ <a href="9482.html" title="Bruno Marchal: &quot;Re: *THE* PUZZLE (was: ascension, Smullyan, ...)&quot;">In reply to</a> ]
<!-- unextthread="start" -->
[ <a href="9486.html" accesskey="t" title="Quentin Anciaux: &quot;Re: *THE* PUZZLE (was: ascension, Smullyan, ...)&quot;">Next in thread</a> ]
 [ <a href="#replies">Replies</a> ]
<!-- ureply="end" -->
</li>
</ul>
</map>
<ul class="links">
<li><a name="options2" id="options2"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg9483" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg9483" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg9483" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg9483" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</div>
<!-- body="start" -->
<div class="mail">
<address class="headers">
<span id="from">
<dfn>From</dfn>: Tom Caylor &lt;<a href="mailto:Daddycaylor.domain.name.hidden?Subject=Re%3A%20*THE*%20PUZZLE%20(was%3A%20ascension%2C%20Smullyan%2C%20...)">Daddycaylor.domain.name.hidden</a>&gt;
</span><br />
<span id="date"><dfn>Date</dfn>: Sat, 10 Jun 2006 17:00:50 -0700</span><br />
</address>
<br />
Bruno Marchal wrote:
<br />
<em class="quotelev1">&gt; Hi,
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Ok Tom, put your security belt because we will leave the constructive
</em><br />
<em class="quotelev1">&gt; area, because it is the price we need to pay, in front of machine, for
</em><br />
<em class="quotelev1">&gt; NOT leaving the finite area.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Let me recall the problem.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; 1) Obviously the set of all computable function from the set of natural
</em><br />
<em class="quotelev1">&gt; number N to the set of natural numbers N is countable (synonym:
</em><br />
<em class="quotelev1">&gt; enumerable, in bijection with N). The reason is that a computable
</em><br />
<em class="quotelev1">&gt; function, by definition, has a code (synonym: a description, a program,
</em><br />
<em class="quotelev1">&gt; a finite machine), that is any finite things which can be used by some
</em><br />
<em class="quotelev1">&gt; entity/machine for computing the functions, and (infinite) sets of
</em><br />
<em class="quotelev1">&gt; finite things are always (infinite and) countable.
</em><br />
<br />If I may, I'd like to revisit why (the motivation) we are considering
<br />
functions from N to N.  I guess it is because all computations are
<br />
equivalent to taking a number from N (i.e. each uniquely meaningful
<br />
input of a computation can be put into a one-to-one correspondence with
<br />
a number from N, because there are countably many inputs) and produce a
<br />
number from N (same reasoning for output as for input).  I guess that
<br />
you are interested in computations because this is what your comp is
<br />
based on.  Your &quot;sufficient level of substitution&quot; is a description of
<br />
a person with countably many symbols.  Right?
<br />
<br /><em class="quotelev1">&gt; Note that a (one) computable function is an infinite object, but giving
</em><br />
<em class="quotelev1">&gt; that that infinite set is computable and generable from a code, the set
</em><br />
<em class="quotelev1">&gt; of computable functions is in bijection with the set of their codes,
</em><br />
<em class="quotelev1">&gt; which itself is in bijection with N, and so the infinite set of
</em><br />
<em class="quotelev1">&gt; infinite objects which are the computable function is in bijection with
</em><br />
<em class="quotelev1">&gt; N.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<br />When you say &quot;infinite object&quot; here, you mean that the function
<br />
computes an infinite number of values, i.e. all the numbers in N.
<br />
Right?  Even though the function is programmed with a finite number of
<br />
symbols, equivalent to a finite number from N.  A function programmed
<br />
with a finite number of symbols, say digits, I can think of as a finite
<br />
number, or if I put a decimal point in front, a rational number.  This
<br />
is equivalent to saying that the rational numbers can be put in a
<br />
one-to-one correspondence (bijection) with N, which is true.  We can
<br />
see that this does not remain true if we allow for infinite programs,
<br />
i.e. a program defined by an infinite number of symbols/digits.  The
<br />
number of such programs is equivalent to the cardinality of the reals
<br />
or the continuum.  So we have to keep in mind that &quot;infinite object&quot;
<br />
refers to the domain of the function, not the description of the
<br />
function.  Right?
<br />
<br /><em class="quotelev1">&gt; 2) Now it looks like we have already a contradiction. let us write f1
</em><br />
<em class="quotelev1">&gt; for the computable function having the least code, f2 the second one,
</em><br />
<em class="quotelev1">&gt; etc.  So we get the sequence f1, f2, f3, f4, f5, ... fn, .... And let
</em><br />
<em class="quotelev1">&gt; us define the function g by
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; g(n) = fn(n) + 1
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; It looks like g is computable isn't it. All fn are computable and can
</em><br />
<em class="quotelev1">&gt; be computed on each n, and certainly adding one (&quot;the + 1&quot;) is
</em><br />
<em class="quotelev1">&gt; computable too. Right?
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Well, if you say &quot;all right&quot; here, we are in trouble. Because if g is
</em><br />
<em class="quotelev1">&gt; really computable, then g is in the sequence of all computable
</em><br />
<em class="quotelev1">&gt; functions fi. But then *there is* a k such that g = fk, and then g(k)
</em><br />
<em class="quotelev1">&gt; is equal to both fk(k) and fk(k)+1, and that gives 0 = 1, by
</em><br />
<em class="quotelev1">&gt; substracting the well-defined number fk(k).
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; So g just cannot be a computable!
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; How could g looks like being computable? It is true that all fn are
</em><br />
<em class="quotelev1">&gt; computable, and it is obviously true that &quot;+ 1&quot; is computable.
</em><br />
<em class="quotelev1">&gt; So, the only thing which is not computable is .... the bijection
</em><br />
<em class="quotelev1">&gt; itself, between N and the fi.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; It is the correspondence:
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; 1 --- f1
</em><br />
<em class="quotelev1">&gt; 2 --- f2
</em><br />
<em class="quotelev1">&gt; 3 --- f3
</em><br />
<em class="quotelev1">&gt; 4 --- f4
</em><br />
<em class="quotelev1">&gt; ....
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; which is NOT computable! There is just no algorithm which can generate
</em><br />
<em class="quotelev1">&gt; the sequence of codes of the computable functions from N to N. So,
</em><br />
<em class="quotelev1">&gt; although each fn is a computable function (from N to N), you cannot
</em><br />
<em class="quotelev1">&gt; diagonalize it for getting g, because to compute g on n, g(n) you need
</em><br />
<em class="quotelev1">&gt; to generate the n first programs corresponding to f1, f2, f3, ... fn,
</em><br />
<em class="quotelev1">&gt; and then apply it to n (and then add one), but you just will never been
</em><br />
<em class="quotelev1">&gt; able to give me a finite set of instructions for doing that. If {f1,
</em><br />
<em class="quotelev1">&gt; f2, f3, ...} are all computable function from N to N, and if the
</em><br />
<em class="quotelev1">&gt; sequence is complete (con,tains all such function) then g, although
</em><br />
<em class="quotelev1">&gt; mathematically well defined, is just not programmable.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<br />This seems to be a result of the fact that we have given *meaning* to
<br />
the symbols, by specifying that the symbols have to make sense in some
<br />
language.  This seems to imply that &quot;attributing meaning to symbols&quot; is
<br />
not algorithmically codable.  If you could code it, then it would be
<br />
programmable (and even computable if it halts).  But then it would just
<br />
be a bunch of numbers being crunched without meaning.
<br />
<br /><em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; BUT THEN .....
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Saying this, it could look like the Universal Dovetailer is still in
</em><br />
<em class="quotelev1">&gt; peril. But I have given you the shape of the solution when I show you
</em><br />
<em class="quotelev1">&gt; the proof of the existence of a irrational number which exponentiated
</em><br />
<em class="quotelev1">&gt; to an irrational number gives a rational number. That precise problem
</em><br />
<em class="quotelev1">&gt; is irrelevant, but the non constructive reasoning I did to prove it is
</em><br />
<em class="quotelev1">&gt; very relevant here. I was telling that there exist some mathematical
</em><br />
<em class="quotelev1">&gt; object, but I was unable to give it. I was only able to give you a bow
</em><br />
<em class="quotelev1">&gt; with the shape
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;     { a   b }
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; telling you the &quot;solution&quot; was in that box (but not saying if it was a
</em><br />
<em class="quotelev1">&gt; or if it was b).
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; The same here, but with an infinite box. I cannot generate mechanically
</em><br />
<em class="quotelev1">&gt; the set {f1, f2, f3, ...} of computable functions, but there is still
</em><br />
<em class="quotelev1">&gt; hope (Church Thesis CT will just express that hope) that I can generate
</em><br />
<em class="quotelev1">&gt; some BIGGER set, containing all computable functions AND MANY OTHER
</em><br />
<em class="quotelev1">&gt; THINGS TOO. The hope is that the OTHER THINGS will help us escaping the
</em><br />
<em class="quotelev1">&gt; diagonal contradiction.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Well, actually CT says more: it says not only that there is a universal
</em><br />
<em class="quotelev1">&gt; language/machine, but that fortran is such a one! And fortran programs
</em><br />
<em class="quotelev1">&gt; are fortran generable, so I can generate a sequence of all fortran
</em><br />
<em class="quotelev1">&gt; one-variable program F1 F2 F3 F4 F5 F6 F7 F8 .... (&quot;all&quot; means that
</em><br />
<em class="quotelev1">&gt; soon or later this sequence goes trough any fortran programs: it is of
</em><br />
<em class="quotelev1">&gt; course an infinite set)
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; So, given that the sequence F1, F2, F3, F4, F5, ... is generable, the
</em><br />
<em class="quotelev1">&gt; corresponding diagonal function G defined by
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; G(n) = Fn(n) + 1
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; *is* programmable in fortran. So there *is* a k such that G = Fk
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; And what will happen if I apply G on its own number-code k?
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Just this: your machine will crash! The fortran interpreter will go in
</em><br />
<em class="quotelev1">&gt; loop or in an infinite computations.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Well, in some formal sense I will get G(k) = G(k) + 1. But I can no
</em><br />
<em class="quotelev1">&gt; more substract G(k) on both sides like we have always do at that stage,
</em><br />
<em class="quotelev1">&gt; because G(k) is just not a well-defined number.
</em><br />
<em class="quotelev1">&gt; It looks like the OTHER THINGS are the function from a subset of N to
</em><br />
<em class="quotelev1">&gt; N. Functions, now, if we want to associate them to the fortran
</em><br />
<em class="quotelev1">&gt; programs, can be only partially defined functions.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; So I can still  hope the sequence Fi of Fortran programs goes trough,
</em><br />
<em class="quotelev1">&gt; among OTHER THINGS, all computable functions everywhere defined, but
</em><br />
<em class="quotelev1">&gt; the price will be that I will got the undefined programmable functions
</em><br />
<em class="quotelev1">&gt; by the same token.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; I give you an infinite box:
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; {F1 F2 F3 F4 F5 F6 F7 F8 F9 ...}
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; but then, I can no more use any algorithmic way to filter out the
</em><br />
<em class="quotelev1">&gt; &quot;solutions&quot; (the computable function from N to N) from the &quot;non
</em><br />
<em class="quotelev1">&gt; solution&quot; (the functions no more everywhere defined, or the function
</em><br />
<em class="quotelev1">&gt; defined on proper subset of N). Why? because if I could do that, I will
</em><br />
<em class="quotelev1">&gt; be able to build an algorithmically  sequence of everywhere defined
</em><br />
<em class="quotelev1">&gt; computable functions, and from that, I hope you are convinced that I
</em><br />
<em class="quotelev1">&gt; *can* prove that 0 = 1.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; The lesson is not yet Godel's incompleteness, but is very close: the
</em><br />
<em class="quotelev1">&gt; price of going through the whole controllable world of computable
</em><br />
<em class="quotelev1">&gt; functions is to accept, hidden among it, the whole uncontrollable world
</em><br />
<em class="quotelev1">&gt; of the undefined functions. They are hidden due to that impossibility
</em><br />
<em class="quotelev1">&gt; of filtering the code of the everywhere define functions from those who
</em><br />
<em class="quotelev1">&gt; are not.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Put in another way: all universal machine can crash. If someone want to
</em><br />
<em class="quotelev1">&gt; sell you a computer with a so clever operating system that the machine
</em><br />
<em class="quotelev1">&gt; never crash, then you know the machine is not universal, or the seller
</em><br />
<em class="quotelev1">&gt; says a falsity.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Hal and Jesse were close. For example:
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev2">&gt; &gt; I was being a little sloppy...it's true that a non-halting program
</em><br />
<em class="quotelev2">&gt; &gt; would not
</em><br />
<em class="quotelev2">&gt; &gt; be equivalent to a computable function, but I think we can at least
</em><br />
<em class="quotelev2">&gt; &gt; say that
</em><br />
<em class="quotelev2">&gt; &gt; the set of all computable functions is a *subset* of the set of all
</em><br />
<em class="quotelev2">&gt; &gt; programs.
</em><br />
<em class="quotelev2">&gt; &gt;
</em><br />
<em class="quotelev2">&gt; &gt; Jesse
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; The key point if, I may insist, is that
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; 1) the superset (of programmable functions, not everywhere defined) is
</em><br />
<em class="quotelev1">&gt; MECHANICALLY enumerable. You can write a fortran program generating
</em><br />
<em class="quotelev1">&gt; their codes.
</em><br />
<em class="quotelev1">&gt; 2) the subset of (computable function from N to N) is enumerable, but
</em><br />
<em class="quotelev1">&gt; is NOT MECHANICALLY enumerable. The bijection with N exists, but is not
</em><br />
<em class="quotelev1">&gt; programmable, in *any* programming language!
</em><br />
<em class="quotelev1">&gt;
</em><br />
<br />I've been wondering about this in the background for a while, so now I
<br />
can ask this question.  OK, I think I understand everything so far.
<br />
But...  if there are functions (in the list of *all* programmable
<br />
functions) which will run forever, and you cannot (computably?) know
<br />
which ones they are (otherwise you could solve the Halting problem?...
<br />
or... at least by the digaonalization reasoning you've given), then
<br />
isn't the Universal Dovetailer going to run into one of these programs
<br />
and run forever?  Alternatively, if the UD executes the first
<br />
instruction of each program, there are a (countably) infinite number of
<br />
programs, so you would never get to the second instruction.
<br />
Alternatively again, are we really allowed to sort the infinite number
<br />
of programs so that we execute the one-instruction programs first,
<br />
followed by the two-instruction programs, etc.?  Isn't this
<br />
non-constructive?
<br />
<br />Tom
<br />
<br /><em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; George ? Are you ok. Now that we have undefined functions; we will be
</em><br />
<em class="quotelev1">&gt; interested in the domain of definition of the programmable functions,
</em><br />
<em class="quotelev1">&gt; and those domain *are* Smullyan's reasoners (in FU). The godelized
</em><br />
<em class="quotelev1">&gt; universe is related with the functions F1 F2 F3 F4 F5 ..., and their
</em><br />
<em class="quotelev1">&gt; domains traditionally noted: W1 W2 W3 W4 W5 W6 W7 ....
</em><br />
<em class="quotelev1">&gt; What we have learned is that we have no algorithm to solve the Wn = N
</em><br />
<em class="quotelev1">&gt; question (you see that? saying Wn = N is the same as saying Fn is
</em><br />
<em class="quotelev1">&gt; defined everywhere or saying Fn is a computable function from N to N).
</em><br />
<em class="quotelev1">&gt; It is an insolubility result. It will be easy, once we get the notion
</em><br />
<em class="quotelev1">&gt; of &quot;theory&quot;, or &quot;chatting machine&quot;, or &quot;recursively enumerable set&quot; to
</em><br />
<em class="quotelev1">&gt; transform that into an incompleteness theorem.
</em><br />
<em class="quotelev1">&gt; Mmh... To get G and G*, more is needed to be honest, but not so much
</em><br />
<em class="quotelev1">&gt; more, just that some &quot;theories&quot; can follow, *in some sense*, all those
</em><br />
<em class="quotelev1">&gt; current posts. But this, is what Smullyan shows, albeit very concisely,
</em><br />
<em class="quotelev1">&gt; in his &quot;heart of the matter&quot;.
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; Bruno
</em><br />
<em class="quotelev1">&gt; 
</em><br />
<em class="quotelev1">&gt; <a href="http://iridia.ulb.ac.be/~marchal/">http://iridia.ulb.ac.be/~marchal/</a>
</em><br />
<br /><br />--~--~---------~--~----~------------~-------~--~----~
<br />
You received this message because you are subscribed to the Google Groups &quot;Everything List&quot; group.
<br />
To post to this group, send email to everything-list.domain.name.hidden
<br />
To unsubscribe from this group, send email to everything-list-unsubscribe.domain.name.hidden
<br />
For more options, visit this group at <a href="http://groups.google.com/group/everything-list">http://groups.google.com/group/everything-list</a>
<br />
-~----------~----~----~----~------~----~------~--~---
<br />
<span id="received"><dfn>Received on</dfn> Sat Jun 10 2006 - 20:01:51 PDT</span>
</div>
<!-- body="end" -->
<div class="foot">
<map id="navbarfoot" name="navbarfoot" title="Related messages">
<ul class="links">
<li><dfn>This message</dfn>: [ <a href="#start9483">Message body</a> ]</li>
<!-- lnext="start" -->
<li><dfn>Next message</dfn>: <a href="9484.html" title="Next message in the list">Tom Caylor: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<li><dfn>Previous message</dfn>: <a href="9482.html" title="Previous message in the list">Bruno Marchal: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<li><dfn>In reply to</dfn>: <a href="9482.html" title="Message to which this message replies">Bruno Marchal: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<!-- lnextthread="start" -->
<li><dfn>Next in thread</dfn>: <a href="9486.html" title="Next message in this discussion thread">Quentin Anciaux: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<li><a name="replies" id="replies"></a>
<dfn>Reply</dfn>: <a href="9486.html" title="Message sent in reply to this message">Quentin Anciaux: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<li><dfn>Reply</dfn>: <a href="9488.html" title="Message sent in reply to this message">Quentin Anciaux: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<li><dfn>Reply</dfn>: <a href="9491.html" title="Message sent in reply to this message">Bruno Marchal: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<!-- lreply="end" -->
</ul>
<ul class="links">
<li><a name="options3" id="options3"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg9483" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg9483" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg9483" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg9483" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</map>
</div>
<!-- trailer="footer" -->
<p><small><em>
This archive was generated by <a href="http://www.hypermail-project.org/">hypermail 2.3.0</a>
: Fri Feb 16 2018 - 13:20:11 PST
</em></small></p>
</body>
</html>
