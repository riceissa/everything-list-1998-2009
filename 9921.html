<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<meta name="generator" content="hypermail 2.3.0, see http://www.hypermail-project.org/" />
<title>Re: Diagonalization (solution-sequel) from Bruno Marchal on 2006-07-15 (everything)</title>
<meta name="Author" content="Bruno Marchal (marchal.domain.name.hidden)" />
<meta name="Subject" content="Re: Diagonalization (solution-sequel)" />
<meta name="Date" content="2006-07-15" />
<style type="text/css">
/*<![CDATA[*/
/* To be incorporated in the main stylesheet, don't code it in hypermail! */
body {color: black; background: #ffffff}
dfn {font-weight: bold;}
pre { background-color:inherit;}
.head { border-bottom:1px solid black;}
.foot { border-top:1px solid black;}
th {font-style:italic;}
table { margin-left:2em;}map ul {list-style:none;}
#mid { font-size:0.9em;}
#received { float:right;}
address { font-style:inherit ;}
/*]]>*/
.quotelev1 {color : #990099}
.quotelev2 {color : #ff7700}
.quotelev3 {color : #007799}
.quotelev4 {color : #95c500}
.period {font-weight: bold}
</style>
</head>
<body>
<div class="head">
<h1>Re: Diagonalization (solution-sequel)</h1>
<!-- received="Sat Jul 15 09:50:02 2006" -->
<!-- isoreceived="20060715165002" -->
<!-- sent="Sat, 15 Jul 2006 15:48:57 +0200" -->
<!-- isosent="20060715134857" -->
<!-- name="Bruno Marchal" -->
<!-- email="marchal.domain.name.hidden" -->
<!-- subject="Re: Diagonalization (solution-sequel)" -->
<!-- id="3307119af2c4129fa2e56a3f529d6dc8.domain.name.hidden" -->
<!-- charset="ISO-8859-1" -->
<!-- inreplyto="1152924972.006070.38080.domain.name.hidden" -->
<!-- expires="-1" -->
<map id="navbar" name="navbar">
<ul class="links">
<li>
<dfn>This message</dfn>:
[ <a href="#start9921" name="options1" id="options1" tabindex="1">Message body</a> ]
 [ More options (<a href="#options2">top</a>, <a href="#options3">bottom</a>) ]
</li>
<li>
<dfn>Related messages</dfn>:
<!-- unext="start" -->
[ <a href="9922.html" accesskey="d" title="Bruno Marchal: &quot;Re: Infinities, cardinality, diagonalisation&quot;">Next message</a> ]
[ <a href="9920.html" title="George Levy: &quot;Re: Theory of Nothing available&quot;">Previous message</a> ]
[ <a href="9919.html" title="Tom Caylor: &quot;Re: Diagonalization (solution-sequel)&quot;">In reply to</a> ]
<!-- unextthread="start" -->
[ <a href="9938.html" accesskey="t" title="Tom Caylor: &quot;Re: Diagonalization (solution-sequel)&quot;">Next in thread</a> ]
 [ <a href="#replies">Replies</a> ]
<!-- ureply="end" -->
</li>
</ul>
</map>
<ul class="links">
<li><a name="options2" id="options2"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg9921" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg9921" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg9921" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg9921" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</div>
<!-- body="start" -->
<div class="mail">
<address class="headers">
<span id="from">
<dfn>From</dfn>: Bruno Marchal &lt;<a href="mailto:marchal.domain.name.hidden?Subject=Re%3A%20Diagonalization%20(solution-sequel)">marchal.domain.name.hidden</a>&gt;
</span><br />
<span id="date"><dfn>Date</dfn>: Sat, 15 Jul 2006 15:48:57 +0200</span><br />
</address>
<br />
Le 15-juil.-06, à 02:56, Tom Caylor a écrit :
<br />
<br /><em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; Bruno Marchal wrote:
</em><br />
<em class="quotelev2">&gt;&gt; Hi Tom,
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt; I will comment your (important imo) first and last paragraph, for
</em><br />
<em class="quotelev2">&gt;&gt; avoiding making the post too much long and technical.
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt; Le 14-juil.-06, à 12:30, Tom Caylor a écrit :
</em><br />
<em class="quotelev3">&gt;&gt;&gt;
</em><br />
<em class="quotelev3">&gt;&gt;&gt; But with Church's Thesis how could it be machine or language 
</em><br />
<em class="quotelev3">&gt;&gt;&gt; dependent?
</em><br />
<em class="quotelev3">&gt;&gt;&gt;  Another way of arguing without the &quot;+ 1&quot; is this:  Define G(n) = 
</em><br />
<em class="quotelev3">&gt;&gt;&gt; Fn(n)
</em><br />
<em class="quotelev3">&gt;&gt;&gt; for all n.  If G is in the list of Fi's, then G=Fk for some fixed k.
</em><br />
<em class="quotelev3">&gt;&gt;&gt; So Fk(n) = Fn(n) for all n.  Now if all you're thinking of is a 
</em><br />
<em class="quotelev3">&gt;&gt;&gt; matrix
</em><br />
<em class="quotelev3">&gt;&gt;&gt; of numbers Fx(y) (a lookup table if you will) with rows numbered by 
</em><br />
<em class="quotelev3">&gt;&gt;&gt; x,
</em><br />
<em class="quotelev3">&gt;&gt;&gt; and columns numbered by y, then this doesn't seem problematic (unless
</em><br />
<em class="quotelev3">&gt;&gt;&gt; you introduce the &quot;+ 1&quot;).  But such a lookup table is infinite and
</em><br />
<em class="quotelev3">&gt;&gt;&gt; therefore is not allowed as the code of a computable function.  You
</em><br />
<em class="quotelev3">&gt;&gt;&gt; need code for the functions Fi.  Specifically, you need code for the
</em><br />
<em class="quotelev3">&gt;&gt;&gt; function Fk (=G).  What does this code look like, even in a universal
</em><br />
<em class="quotelev3">&gt;&gt;&gt; sense?  Well Fk(n) = G(n) = Fn(n) for all n, so Fk would have to have
</em><br />
<em class="quotelev3">&gt;&gt;&gt; some code to compute Fk(1)=F1(1), Fk(2)=F2(2), Fk(3)=F3(3), 
</em><br />
<em class="quotelev3">&gt;&gt;&gt; ...Fk(k)=?,
</em><br />
<em class="quotelev3">&gt;&gt;&gt; ...
</em><br />
<em class="quotelev3">&gt;&gt;&gt; How does Fk *ever* know what to compute for Fk(k)?  This is actually
</em><br />
<em class="quotelev3">&gt;&gt;&gt; rather funny to me.  It's like me being my own grandpa.  It seems 
</em><br />
<em class="quotelev3">&gt;&gt;&gt; that
</em><br />
<em class="quotelev3">&gt;&gt;&gt; there already is a case of G(n) not being defined for n=k, even 
</em><br />
<em class="quotelev3">&gt;&gt;&gt; without
</em><br />
<em class="quotelev3">&gt;&gt;&gt; the &quot;+ 1&quot;.
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt; Remember that the Fi are the partial computable function. You can
</em><br />
<em class="quotelev2">&gt;&gt; generate the set of codes, written in some universal language, of all
</em><br />
<em class="quotelev2">&gt;&gt; those functions. To fix the idea I choose often the universal language
</em><br />
<em class="quotelev2">&gt;&gt; fortran, but choose any of your favorite one.
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt; Let us then define, like you propose, the diagonal function G by G(n) 
</em><br />
<em class="quotelev2">&gt;&gt; =
</em><br />
<em class="quotelev2">&gt;&gt; Fn(n).
</em><br />
<em class="quotelev2">&gt;&gt; Now the Fn are fortran generable, and they are partially computable. 
</em><br />
<em class="quotelev2">&gt;&gt; So
</em><br />
<em class="quotelev2">&gt;&gt; it is easy to write a program computing G:
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt; --------
</em><br />
<em class="quotelev2">&gt;&gt; Begin
</em><br />
<em class="quotelev2">&gt;&gt; read x;
</em><br />
<em class="quotelev2">&gt;&gt; generate (by using the lexicographic order) the code of the Fi up to
</em><br />
<em class="quotelev2">&gt;&gt; the code of Fx;
</em><br />
<em class="quotelev2">&gt;&gt; ouput the result of applying the xth program on x;       (or
</em><br />
<em class="quotelev2">&gt;&gt; equivalently compute Fx(x), or just call
</em><br />
<em class="quotelev2">&gt;&gt;                      the universal function u(x,x) if you recall it).
</em><br />
<em class="quotelev2">&gt;&gt; End
</em><br />
<em class="quotelev2">&gt;&gt; ---------
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt; Now this is a finite fortran program. So it belongs to the list of
</em><br />
<em class="quotelev2">&gt;&gt; codes of the program Fi, and you can find that code, so you can find
</em><br />
<em class="quotelev2">&gt;&gt; the indice k of the function Fk = G through the explicit program 
</em><br />
<em class="quotelev2">&gt;&gt; above.
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt; So, now, you can apply G on k, giving G(k) = Fk(k).
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev2">&gt;&gt; This does not give any information (unlike with G(x) = Fx(x) + 1 where
</em><br />
<em class="quotelev2">&gt;&gt; you get a proof that this G is undefined on its own code). Your G
</em><br />
<em class="quotelev2">&gt;&gt; (where G(x) = Fx(x) could be, or not, defined on its own code).
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; You've written a sort of intuitive code for G above, where you say
</em><br />
<em class="quotelev1">&gt; &quot;generate&quot;.
</em><br />
<br /><br /><br /><br /><br />Yes. With Church thesis fortran *is* universal.
<br />
Fortran, like Java, Python, Lisp, Diophantine equations, rational 
<br />
unitary matrices or other rich recursively presented groups, etc... 
<br />
Chose your favorite one, once and for all. To fiw the idea I take 
<br />
fortran, and old and venerable programming language.
<br />
Those language are grammatically well defined.
<br />
So you *can* write a well defined precise (I would even say concrete) 
<br />
program fortran capable of generating all fortran programs computing 
<br />
function of one variable. It is enough to write a program which 
<br />
generate successively all strings of length n, and which filter out 
<br />
those strings which are not fortran one variable programs.
<br />
I gave an intuitive code just for not alarming people with piece of 
<br />
code, but it should be clear that anyone knowing at least one 
<br />
programming language, and knowing the notion of alphabetic order on a 
<br />
finite set of symbols (like the keyboard buttons of a computer) should 
<br />
be able to write, in that programming language, a program generating 
<br />
(just generating) successively all the (one variable) programs in that 
<br />
language. Then by coding &quot;finite inputs&quot; by natural numbers, you can 
<br />
think of those programs as computing functions from N to N, or from 
<br />
subset of N to N.
<br />
<br />If you agree with this, you agree with the fact that there is a 
<br />
program, let us call it GEN, in fortran which generates the sequence of 
<br />
codes P1 P2 P3 P4 P5 P6 ... Now the partial computable functions are 
<br />
those functions computed by those programs, and I wrote the sequence of 
<br />
those functions Fi. That is F1 F2 F3 F4 F5 F6 F7 F8 ...
<br />
<br />Note that GEN is not in the list {P1 P2 P3 P4 P5 P6 ...} for the non 
<br />
interesting contingent fact that GEN is a 0 variable program.
<br />
But GEN2, defined by GEN2(n) = the code of the nth program in the list, 
<br />
belongs to the list, given that GEN2 is a one variable program. So 
<br />
GEN2(1) = P1,  GEN2(2) = P2, GEN2(3) = P3, etc.
<br />
And now, giving that GEN2 is in the list, there is a number k such that 
<br />
GEN2 = Pk. Nothing magic here. True: GEN2(k) = Pk. Nothing paradoxical 
<br />
here. GEN2 compute a total function, that is GEN2 on any n gives the 
<br />
nth programs, and (diagonlaization), on its own indice k it gives its 
<br />
own code Pk.
<br />
<br />Now *your* G is just defined by G(n) = GEN2(n). It will use most 
<br />
probably GEN as subroutine. I have already send to this list the code 
<br />
of a GEN2 in LISP.
<br />
You can prove nothing with it. Like if an inhabitant of the Knight 
<br />
Knave Island tell you &quot;I am a Knight&quot; It could be true (Knight always 
<br />
tell the truth) or a lie (Knaves always lie).
<br />
<br />*My* function G is defined by G(n) = GEN2(n) +1.
<br />
<br />And given that we have already program GEN2, it is a child play to 
<br />
modify the program computing your G into mine: just add the instruction 
<br />
&quot;+ 1&quot; at the right place.
<br />
<br />Now, in case that G would be a total function, we would be in a 
<br />
situation analog with what happens if you meet a inhabitant of the 
<br />
Knight Knave Island saying &quot;I am a Knave&quot;, a total impossibility (if a 
<br />
knave says it it would tell the truth which a knave never does, and a 
<br />
Knight will never say the falsity &quot;I am a knave&quot;. It is the &quot;+ 1&quot; which 
<br />
force the G function to be wrong in all case you give her its own 
<br />
indice, as we have seen.
<br />
<br /><br /><br /><br /><em class="quotelev1">&gt; But if G = Fk, then when we go to explicitly write the
</em><br />
<em class="quotelev1">&gt; code for G, when we get to &quot;generate the code for Fk&quot; what to we write?
</em><br />
<br /><br />GEN generates all the codes. Like if I count 0, 1, 2, 3, .... without 
<br />
ever stopping (in platonia) soon or later (actually later!) I will get 
<br />
some of my correct Godel number describing me at the right level of 
<br />
description. I will not be aware of that, but this is not the point. 
<br />
GEN generates algorithmically, mechanically, &quot;fortranically&quot; all the 
<br />
fortran codes. If you doubt this can be done, the best is that you 
<br />
write the code for yourself.
<br />
<br /><br /><br /><br /><em class="quotelev1">&gt;  Fk *is* G. So we start generating G from the beginning until we again
</em><br />
<em class="quotelev1">&gt; get to the part &quot;generate the code for Fk&quot; and then we do this forever.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; It's sort of like at dinner when I ask my son or daughter what they did
</em><br />
<em class="quotelev1">&gt; today, and they tell me everything they did starting with &quot;I woke up
</em><br />
<em class="quotelev1">&gt; and made my bed...&quot;, and jokingly they finally say, &quot;...and then sat
</em><br />
<em class="quotelev1">&gt; down for dinner and told you, 'I woke up and made my bed...' ...&quot;  But
</em><br />
<em class="quotelev1">&gt; of course they finally stop and laugh, instead of going forever.
</em><br />
<br /><br />Something similar happens with the universal dovetailing. But here we 
<br />
use just the program generating part of the dovetailing. Your G as 
<br />
mine, applied to n, does compute directly, without dovetailing the 
<br />
value Fn(n) or Fn(n)+1 (cf Fn is the function computed by the program 
<br />
Pn).
<br />
<br /><br /><br /><br /><em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; This is where I'm stumped.  You say that we escape the diagonalization
</em><br />
<em class="quotelev1">&gt; and the program runs forever (because 0 is not equal to 1).  I'm trying
</em><br />
<em class="quotelev1">&gt; to get a firm handle on what is actually going on here.
</em><br />
<br /><br />You are right to do so. Understanding the (effective, programmable) 
<br />
diagonalization of the Fi, is needed to proceed. It shows that IF 
<br />
Church thesis is correct so that the Fi contains all the total 
<br />
computable functions (that is the Pi contains all the codes of the 
<br />
total computable functions) THEN the code of the total function is 
<br />
necessarily HIDDEN in the Fi. No algorithmic procedure capable of 
<br />
distinuishing the Pi computing total comp. function from the Pi 
<br />
computing the proper partial one will ever exist. As I shown this shows 
<br />
quickly both insolubility and incompleteness.
<br />
<br /><br /><br /><br /><em class="quotelev1">&gt; Is there some
</em><br />
<em class="quotelev1">&gt; intuitive definition that is causing an ambiguity, just like the
</em><br />
<em class="quotelev1">&gt; definition of a function itself, as in my previous post?
</em><br />
<br /><br />I don't think there is anything conceptually ambiguous once you accept 
<br />
CT. What has been  proved to be necessarily mathematically ambiguous is 
<br />
the notion of total computable function; in the sense that we have 
<br />
prove that NO algorithm can test in general the totality or proper 
<br />
partiality of the function computed by some code.
<br />
<br />This is gives us two path in the conquest of the &quot;controllable world&quot;. 
<br />
Either from inside by augmenting in the constructive transfinite RE 
<br />
*subset* of the set of codes for total functions. This is mainly the 
<br />
path toward the first person plenitude; or by accepting the jump toward 
<br />
the partial functions and learning to live together with a partially 
<br />
non controllable reality. It is akin to the third person jump of act of 
<br />
faith, but it is also the openness toward the others (which you cannot 
<br />
control).
<br />
<br />Tell me if you are convince that &quot;your&quot; and &quot;my&quot; G are programmable.
<br />
<br />You would be kind to tell me if you understand my preceding posts after 
<br />
getting that G is programmable. (I thought you already get that GEN was 
<br />
programmable). You should understand that I have proved rigorously 
<br />
(thanks to CT) the incompleteness of computer science. To prove the 
<br />
incompleteness of arithmetic/number theory from that consists only in 
<br />
showing that enough of computer science can be translated in number 
<br />
theory to inherit essential incompleteness. One path is Godel's 
<br />
arithmetization, another one, quite beautiful, is the study of the 
<br />
Diophantine equations, the work of Matiyasevich(*) ... (RE set can be 
<br />
characterized by Diophantine sets of numbers. Diophantus is a 
<br />
contemporary to Plotinus, about 200-300 after JC).
<br />
This is needed to understand how the many computational histories are 
<br />
implemented in all possible sort of ways in the realm of numbers, and 
<br />
later how they interfere when seen from inside, and how from inside 
<br />
(from 1 povs) all plotinus hypostases get arithmetical interpretations, 
<br />
including the one describing &quot;matter&quot;, which we can then be compared to 
<br />
the empirical quantum, to test the comp hypothesis. OK?
<br />
<br />Bruno
<br />
<br />(*) Yuri V. Matiyasevich (foreword by Martin Davis), Third printing 
<br />
1996, Hilbert's Tenth Problem, The MIT Press (1993 Russian Edition).
<br />
<br /><a href="http://iridia.ulb.ac.be/~marchal/">http://iridia.ulb.ac.be/~marchal/</a>
<br />
<br /><br />--~--~---------~--~----~------------~-------~--~----~
<br />
You received this message because you are subscribed to the Google Groups &quot;Everything List&quot; group.
<br />
To post to this group, send email to everything-list.domain.name.hidden
<br />
To unsubscribe from this group, send email to everything-list-unsubscribe.domain.name.hidden
<br />
For more options, visit this group at <a href="http://groups.google.com/group/everything-list">http://groups.google.com/group/everything-list</a>
<br />
-~----------~----~----~----~------~----~------~--~---
<br />
<span id="received"><dfn>Received on</dfn> Sat Jul 15 2006 - 09:50:02 PDT</span>
</div>
<!-- body="end" -->
<div class="foot">
<map id="navbarfoot" name="navbarfoot" title="Related messages">
<ul class="links">
<li><dfn>This message</dfn>: [ <a href="#start9921">Message body</a> ]</li>
<!-- lnext="start" -->
<li><dfn>Next message</dfn>: <a href="9922.html" title="Next message in the list">Bruno Marchal: "Re: Infinities, cardinality, diagonalisation"</a></li>
<li><dfn>Previous message</dfn>: <a href="9920.html" title="Previous message in the list">George Levy: "Re: Theory of Nothing available"</a></li>
<li><dfn>In reply to</dfn>: <a href="9919.html" title="Message to which this message replies">Tom Caylor: "Re: Diagonalization (solution-sequel)"</a></li>
<!-- lnextthread="start" -->
<li><dfn>Next in thread</dfn>: <a href="9938.html" title="Next message in this discussion thread">Tom Caylor: "Re: Diagonalization (solution-sequel)"</a></li>
<li><a name="replies" id="replies"></a>
<dfn>Reply</dfn>: <a href="9938.html" title="Message sent in reply to this message">Tom Caylor: "Re: Diagonalization (solution-sequel)"</a></li>
<!-- lreply="end" -->
</ul>
<ul class="links">
<li><a name="options3" id="options3"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg9921" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg9921" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg9921" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg9921" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</map>
</div>
<!-- trailer="footer" -->
<p><small><em>
This archive was generated by <a href="http://www.hypermail-project.org/">hypermail 2.3.0</a>
: Fri Feb 16 2018 - 13:20:11 PST
</em></small></p>
</body>
</html>
