<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="hypermail 2.3.0, see http://www.hypermail-project.org/" />
<title>Re: Program for UD from Marchal on 2001-05-03 (everything)</title>
<meta name="Author" content="Marchal (marchal.domain.name.hidden)" />
<meta name="Subject" content="Re: Program for UD" />
<meta name="Date" content="2001-05-03" />
<style type="text/css">
/*<![CDATA[*/
/* To be incorporated in the main stylesheet, don't code it in hypermail! */
body {color: black; background: #ffffff}
dfn {font-weight: bold;}
pre { background-color:inherit;}
.head { border-bottom:1px solid black;}
.foot { border-top:1px solid black;}
th {font-style:italic;}
table { margin-left:2em;}map ul {list-style:none;}
#mid { font-size:0.9em;}
#received { float:right;}
address { font-style:inherit ;}
/*]]>*/
.quotelev1 {color : #990099}
.quotelev2 {color : #ff7700}
.quotelev3 {color : #007799}
.quotelev4 {color : #95c500}
.period {font-weight: bold}
</style>
</head>
<body>
<div class="head">
<h1>Re: Program for UD</h1>
<!-- received="Thu May  3 02:23:12 2001" -->
<!-- isoreceived="20010503092312" -->
<!-- sent="Thu May  3 02:23:12 2001" -->
<!-- isosent="20010503092312" -->
<!-- name="Marchal" -->
<!-- email="marchal.domain.name.hidden" -->
<!-- subject="Re: Program for UD" -->
<!-- id="200105030918.LAA15290.domain.name.hidden" -->
<!-- charset="iso-8859-1" -->
<!-- inreplyto="Program for UD" -->
<!-- expires="-1" -->
<map id="navbar" name="navbar">
<ul class="links">
<li>
<dfn>This message</dfn>:
[ <a href="#start2821" name="options1" id="options1" tabindex="1">Message body</a> ]
 [ More options (<a href="#options2">top</a>, <a href="#options3">bottom</a>) ]
</li>
<li>
<dfn>Related messages</dfn>:
<!-- unext="start" -->
[ <a href="2822.html" accesskey="d" title="Marchal: &quot;Re: The role of logic, &#0038; planning ...&quot;">Next message</a> ]
[ <a href="2820.html" title="Marchal: &quot;Re: Belief &#0038; Knowledge&quot;">Previous message</a> ]
[ <a href="2814.html" title="hal.domain.name.hidden: &quot;Program for UD&quot;">Maybe in reply to</a> ]
<!-- unextthread="start" -->
[ <a href="2829.html" accesskey="t" title="Marchal: &quot;Re: Program for UD&quot;">Next in thread</a> ]
<!-- ureply="end" -->
</li>
</ul>
</map>
<ul class="links">
<li><a name="options2" id="options2"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg2821" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg2821" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg2821" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg2821" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</div>
<!-- body="start" -->
<div class="mail">
<address class="headers">
<span id="from">
<dfn>From</dfn>: Marchal &lt;<a href="mailto:marchal.domain.name.hidden?Subject=Re%3A%20Program%20for%20UD">marchal.domain.name.hidden</a>&gt;
</span><br />
<span id="date"><dfn>Date</dfn>: Thu May  3 02:23:12 2001</span><br />
</address>
<br />
Hal Finney wrote:
<br />
<br /><em class="quotelev1">&gt;Has anyone proposed a specific implementation for the Universal Dovetailer
</em><br />
<em class="quotelev1">&gt;(UD)?
</em><br />
<br /><br />Here is the UD from my technical reports. It is the complete definition,
<br />
and it is written in a standard LISP, so you can run it and indeed compute 
<br />
Chaitin's Omega. 
<br />
Some people asked me from time to time my UD program.  I put in on the list 
<br />
for further reference.
<br />
Note that it dovetails on LISP programs.
<br />
Samples of executions are included.
<br />
Sorry for the french commentaries.
<br />
<br /><br />==========================
<br />
4.4 Annexe GEN &amp; DU
<br />
<br />4.4.1 GEN  (Générateur programmes et données)
<br />
<br /><br /><br />contient next-programme, next-data
<br />
<br /><br />bijection entre w et LISTE : NEXT
<br />
&nbsp;fonction next avec choix des atomes (voir initialisation)
<br />
<br /><br />(defun big-jump-a (l)
<br />
&nbsp;(cond ((last-atom? l)(cons (first-atom) nil))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l (cons (last-atom) nil))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons (cons (first-atom) nil)nil))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t (cons (big-jump-a (cdr l)) nil))
<br />
&nbsp;))
<br />
<br />(defun jump-aux-a (l aux)
<br />
&nbsp;(cond ((equal (car l)(last-atom))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(jump-aux-a (cdr l) (cons (first-atom) aux)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((null (cdr l)) (cons (caar (big-jump-a (car l)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons (first-atom) aux)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t (append (cons (caar (big-jump-a (car l))) aux)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons (big-jump-a (cadr l)) (cddr l))))
<br />
&nbsp;))
<br />
<br />(defun jump-a (l)
<br />
&nbsp;(cond ((null l) (cons (first-atom) nil))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((list-last-atom l) (big-jump-a l))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t (jump-aux-a l nil))
<br />
&nbsp;))
<br />
<br />(defun list-last-atom (l)
<br />
&nbsp;(cond ((null l) t)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((atom l) nil)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((last-atom? (car l))(list-last-atom (cdr l)))
<br />
&nbsp;))
<br />
<br />(defun complet-a (l)
<br />
&nbsp;(or (last-atom? l) (list-last-atom l))
<br />
&nbsp;)
<br />
<br />(defun list-complet-a (l)
<br />
&nbsp;(cond ((null l) t)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((complet-a (car l)) (list-complet-a (cdr l)))
<br />
&nbsp;))
<br />
<br />(defun faire-premier-a (listatom)
<br />
&nbsp;(car (big-jump-a listatom))
<br />
&nbsp;)
<br />
<br />(defun next-i-a (l)
<br />
&nbsp;(cond ((not (complet-a (car l)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons (next-a (car l)) (cdr l)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t (cons (faire-premier-a (car l))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(next-i-a (cdr l)) ))
<br />
&nbsp;))
<br />
<br /><br /><br /><br /><br />(defun next-a (l)
<br />
&nbsp;(cond ((null l)(first-atom))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((atom l)(next-atom l))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((list-complet-a l)(jump-a l))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t (next-i-a l))
<br />
&nbsp;))
<br />
<br /><br />initialisation 1   (deux atomes)
<br />
<br /><br />&nbsp;(defun first-atom ()
<br />
&nbsp;&nbsp;&nbsp;'a)
<br />
&nbsp;
<br />
&nbsp;(defun last-atom? (l)
<br />
&nbsp;&nbsp;(equal l 'b)
<br />
&nbsp;&nbsp;)
<br />
<br />&nbsp;(defun last-atom ()
<br />
&nbsp;&nbsp;'b)
<br />
<br />&nbsp;(defun next-atom (l)
<br />
&nbsp;&nbsp;&nbsp;(cond
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l 'a) 'b)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l 'b) '(a))
<br />
&nbsp;&nbsp;))
<br />
<br /><br /><br />initialisation 2  (petits programmes LISP)
<br />
<br /><br />(defun first-atom ()
<br />
&nbsp;&nbsp;&nbsp;'equal)
<br />
&nbsp;
<br />
&nbsp;(defun last-atom? (l)
<br />
&nbsp;&nbsp;(equal l 'null)
<br />
&nbsp;&nbsp;)
<br />
<br />&nbsp;(defun last-atom ()
<br />
&nbsp;&nbsp;'null)
<br />
<br />&nbsp;(defun next-atom (l)
<br />
&nbsp;&nbsp;&nbsp;(cond
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l 'equal) 'car)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l 'car) 'cdr)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l 'cdr) 'x)     
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l 'x) 'quote)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l 'quote) 'lambda)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l 'lambda) 'k)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l 'k) 'cons)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l 'cons) 'cond)     
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l 'cond) 'null)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal l 'null) '(equal))   nil = (equal 'null 'cond)
<br />
&nbsp;&nbsp;))
<br />
<br /><br /><br />filtre brut pour les petits programmes
<br />
<br /><br />(defun var (x)
<br />
&nbsp;(equal x 'x)
<br />
&nbsp;)
<br />
<br /><br />(defun sf (x n)
<br />
&nbsp;(or (and (equal x 'quote)(equal n 1))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and (equal x 'car)(equal n 1))              
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and (equal x 'cdr)(equal n 1))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and (equal x 'k)(equal n 1))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and (equal x 'cons)(equal n 2))
<br />
&nbsp;))
<br />
<br />(defun sr (x n)
<br />
&nbsp;(or (and (equal x 'null)(equal n 1))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and (equal x 'equal)(equal n 2)))
<br />
)
<br />
<br />(defun terme (x)
<br />
&nbsp;(cond ((atom x)(var x))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t (or (and (equal (car x) 'quote)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(not (null (cdr x)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(null (cddr x)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and (sf (car x)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(length (cdr x)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-terme (cdr x))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)))
<br />
&nbsp;))
<br />
dans DU 2 on tient compte du terme constant
<br />
<br />(defun list-terme (x)
<br />
&nbsp;(cond ((null x) t)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((terme (car x)) (list-terme (cdr x)))
<br />
&nbsp;))
<br />
<br />(defun prop (x)
<br />
&nbsp;(or (equal x nil)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(equal x 't)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and (listp x)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sr (car x)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(length (cdr x)) )
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-terme (cdr x)))
<br />
&nbsp;))
<br />
<br />(defun exp-cond (x)
<br />
&nbsp;(and (listp x)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(equal (car x) 'cond)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(test (cadr x))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-test (cddr x))
<br />
&nbsp;))
<br />
<br /><br />(defun test (x)
<br />
&nbsp;(and (listp x)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(null (cddr x))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(prop (car x))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(terme (cadr x))
<br />
&nbsp;))
<br />
<br />(defun list-test (x)
<br />
&nbsp;(cond ((null x) t)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((test (car x)) (list-test (cdr x)))
<br />
&nbsp;))
<br />
<br />(defun bod (x)
<br />
&nbsp;(or (terme x)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(prop x)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exp-cond x)
<br />
&nbsp;))
<br />
<br />boucles génératives
<br />
<br /><br />(defun boum (x)
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a x)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-a a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b))
<br />
&nbsp;)
<br />
<br />(defun brol (x)
<br />
&nbsp;(prog (a c)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a x)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-a a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq c (read-char))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond ((equal c #\Space )(print a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t (print '(barre d'espacement!...))))
<br />
j'ai trouvé &quot;#\Space&quot; en éxécutant (print (read-char)) !  
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b))
<br />
&nbsp;)
<br />
<br />(defun gen (x)
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a x)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-a a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond ((bod a )(print (list 'lambda '(x) a)))) 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b))
<br />
&nbsp;)  
<br />
<br /><br /><br />éxécution :
<br />
<br />? (gen nil)       il s'agit de gen le vieux
<br />
<br />(LAMBDA (X) X) 
<br />
(LAMBDA (X) (CAR X)) 
<br />
(LAMBDA (X) (CDR X)) 
<br />
(LAMBDA (X) 'X) 
<br />
(LAMBDA (X) (NULL X)) 
<br />
(LAMBDA (X) (EQUAL X X)) 
<br />
<br />Aborted
<br />
? 
<br />
<br /><br /><br />voilà le dernier gen (celui de gen prog data)
<br />
<br />? (gen nil)
<br />
<br />(LAMBDA (X) X) 
<br />
(LAMBDA (X) 'EQUAL) 
<br />
(LAMBDA (X) 'CAR) 
<br />
(LAMBDA (X) 'CDR) 
<br />
(LAMBDA (X) (CAR X)) 
<br />
(LAMBDA (X) (CDR X)) 
<br />
(LAMBDA (X) 'X) 
<br />
(LAMBDA (X) (K X)) 
<br />
(LAMBDA (X) (NULL X)) 
<br />
(LAMBDA (X) 'QUOTE) 
<br />
(LAMBDA (X) 'LAMBDA) 
<br />
(LAMBDA (X) 'K) 
<br />
(LAMBDA (X) 'CONS) 
<br />
(LAMBDA (X) 'COND) 
<br />
(LAMBDA (X) 'NULL) 
<br />
(LAMBDA (X) '(EQUAL)) 
<br />
(LAMBDA (X) '(CAR)) 
<br />
(LAMBDA (X) '(CDR)) 
<br />
(LAMBDA (X) '(X)) 
<br />
(LAMBDA (X) '(QUOTE)) 
<br />
(LAMBDA (X) '(LAMBDA)) 
<br />
(LAMBDA (X) '(K)) 
<br />
(LAMBDA (X) '(CONS)) 
<br />
(LAMBDA (X) '(COND)) 
<br />
(LAMBDA (X) '(NULL)) 
<br />
(LAMBDA (X) (EQUAL X X)) 
<br />
(LAMBDA (X) (CONS X X))
<br />
<br /><br /><br />next-programme &amp; next-data (sur le mode de la conversation)
<br />
<br />(defun next-programme (p)
<br />
&nbsp;&nbsp;(let ((b (next-a (body p)) ))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(cond ((bod b) (list 'lambda (list 'x) b))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t (next-programme (list 'lambda (list 'x) b)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;)  cela aurait été plus joli avec un next-body ! (passons)
<br />
<br />(defun next-data (d)
<br />
&nbsp;&nbsp;(list 'quote (next-a (cadr d)))
<br />
&nbsp;&nbsp;)
<br />
<br />(defun next-programme-avec-nouvelle-var (p)
<br />
&nbsp;(let ((b (next-a (body p)) )
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new-var (gensym)))
<br />
&nbsp;&nbsp;&nbsp;(cond ((bod b) (list 'lambda (list new-var) (subst new-var 'x b)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t (next-programme (list 'lambda (list 'x) b)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;)  
<br />
<br />ne marche pas : E-step devra appeler gensym lui-même après avoir effectué
<br />
next-programme.
<br />
ça ne marche pas car x joue un rôle privilégié (pour aller plus vite dans la
<br />
de programme.
<br />
<br />a moins d'appeler next-programme et de substituer les variables avant et après:
<br />
<br /><br /><br /><br /><br />(defun next-programme-avec-nouvelle-var (p)
<br />
&nbsp;(let ((px (remettre-x p))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new-var (gensym)))
<br />
&nbsp;&nbsp;&nbsp;(subst new-var 'x (next-programme px))
<br />
&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;)
<br />
pas besoin de let :
<br />
<br />(defun next-panv (p)
<br />
&nbsp;&nbsp;(cond ((null p) '(lambda (x) x))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(T (next-programme-avec-nouvelle-var p))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;) pour partir de nil.
<br />
<br />(defun next-programme-avec-nouvelle-var (p)   
<br />
&nbsp;&nbsp;(subst (gentemp) 'x (next-programme (remettre-x p)))
<br />
&nbsp;&nbsp;)
<br />
<br /><br />(defun remettre-x (p)
<br />
&nbsp;&nbsp;(subst 'x (car (argu p)) p)
<br />
&nbsp;&nbsp;)
<br />
<br />&nbsp;&nbsp;
<br />
<br />&nbsp;&nbsp;test
<br />
<br />? 
<br />
(defun test-data ()
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a nil)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-data a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b)))
<br />
<br /><br />'EQUAL 
<br />
'CAR 
<br />
'CDR 
<br />
'X 
<br />
'QUOTE 
<br />
'LAMBDA 
<br />
'K 
<br />
'CONS 
<br />
'COND 
<br />
'NULL 
<br />
'(EQUAL) 
<br />
'(CAR) 
<br />
'(CDR) 
<br />
'(X) 
<br />
'(QUOTE) 
<br />
'(LAMBDA) 
<br />
'(K) 
<br />
'(CONS) 
<br />
'(COND) 
<br />
'(NULL) 
<br />
'((EQUAL)) 
<br />
'((CAR)) 
<br />
'((CDR)) 
<br />
'((X)) 
<br />
'((QUOTE)) 
<br />
'((LAMBDA)) 
<br />
'((K)) 
<br />
'((CONS)) 
<br />
'((COND)) 
<br />
'((NULL)) 
<br />
'(EQUAL EQUAL) 
<br />
'(CAR EQUAL)                   ON N'A PAS LA DONNEE &quot;NIL&quot;!!
<br />
'(CDR EQUAL) 
<br />
'(X EQUAL) 
<br />
<br />? 
<br />
(defun test-npanv ()
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a NIL)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-programme-avec-nouvelle-var a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b)))
<br />
<br /><br />Compiler warnings for function TEST-NPANV :       (???)
<br />
&nbsp;&nbsp;Undeclared free variable (I)
<br />
TEST-NPANV
<br />
? (test-npanv)                  ne marche pas à partir de nil !
<br />
<br />(LAMBDA (#:G313) 'EQUAL) 
<br />
(LAMBDA (#:G314) 'CAR) 
<br />
(LAMBDA (#:G315) 'CDR) 
<br />
(LAMBDA (#:G316) (CAR #:G316)) 
<br />
(LAMBDA (#:G317) (CDR #:G317)) 
<br />
(LAMBDA (#:G318) '#:G318) 
<br />
(LAMBDA (#:G319) (K #:G319)) 
<br />
(LAMBDA (#:G320) (NULL #:G320)) 
<br />
(LAMBDA (#:G321) 'QUOTE) 
<br />
(LAMBDA (#:G322) 'LAMBDA) 
<br />
(LAMBDA (#:G323) 'K) 
<br />
(LAMBDA (#:G324) 'CONS) 
<br />
(LAMBDA (#:G325) 'COND) 
<br />
(LAMBDA (#:G326) 'NULL) 
<br />
(LAMBDA (#:G327) '(EQUAL)) 
<br />
(LAMBDA (#:G328) '(CAR)) 
<br />
(LAMBDA (#:G329) '(CDR)) 
<br />
(LAMBDA (#:G330) '(#:G330)) 
<br />
(LAMBDA (#:G331) '(QUOTE)) 
<br />
(LAMBDA (#:G332) '(LAMBDA)) 
<br />
(LAMBDA (#:G333) '(K)) 
<br />
(LAMBDA (#:G334) '(CONS)) 
<br />
(LAMBDA (#:G335) '(COND)) 
<br />
(LAMBDA (#:G336) '(NULL)) 
<br />
(LAMBDA (#:G337) (EQUAL #:G337 #:G337)) 
<br />
(LAMBDA (#:G338) (CONS #:G338 #:G338)) 
<br />
(LAMBDA (#:G339) '((EQUAL))) 
<br />
<br /><br />encore un problème
<br />
<br />? ACL ne comprend pas :
<br />
? ((LAMBDA (#:G313) #:G313) 'a)
<br />
<em class="quotelev1">&gt; Error: Unbound variable: #:G313 .
</em><br />
<em class="quotelev1">&gt; While executing: SYMBOL-VALUE
</em><br />
<em class="quotelev1">&gt; Type Command-/ to continue, Command-. to abort.
</em><br />
1 &gt; 
<br />
<br />plus étrange F-lisp ne comprend pas non plus :(avec même type de message)
<br />
<br />(e '((LAMBDA (#:G313) #:G313) 'a) en)
<br />
(ERREUR #:G313 C-EST-QUOI-?)
<br />
? (e '((lambda (b) b) 'a) en)
<br />
A
<br />
? (atom #:G313)
<br />
<em class="quotelev1">&gt; Error: Unbound variable: #:G313 .
</em><br />
<em class="quotelev1">&gt; While executing: SYMBOL-VALUE
</em><br />
<em class="quotelev1">&gt; Type Command-/ to continue, Command-. to abort.
</em><br />
1 &gt; (atom '#:G313)
<br />
T
<br />
alors que F-lisp accepte n'importe qu'elle atome :
<br />
1 &gt; (e '((lambda (3) 3) 'a) en)
<br />
A
<br />
à la différence de ACL qui refuse une lambda expression du type
<br />
((lambda (3) 3) 'a).
<br />
<br /><br />1 &gt; ((lambda (#:G313) (car #:G313)) '(a b c))
<br />
<em class="quotelev1">&gt; Error: Unbound variable: #:G313 .
</em><br />
<em class="quotelev1">&gt; While executing: SYMBOL-VALUE
</em><br />
<em class="quotelev1">&gt; Type Command-/ to continue, Command-. to abort.
</em><br />
2 &gt; ((lambda (x) (car x)) '(a b c))
<br />
A
<br />
2 &gt; 
<br />
<br />encore plus bizarre :
<br />
2 &gt; (remettre-x '(lambda (#:G313) (car #:G313)))
<br />
(LAMBDA (X) (CAR #:G313))
<br />
2 &gt; (remettre-x '(lambda (#:G262) (car (cdr #:G262))))
<br />
(LAMBDA (X) (CAR (CDR #:G262)))
<br />
2 &gt; 
<br />
<br />plus bizarre car test-npanv a fonctionné ! (et fonctionne encore)
<br />
<br />et ceci !?! :
<br />
? (equal '(#:G262) '(#:G262))
<br />
NIL
<br />
<br />encore des tests :
<br />
<br />(defun ?1 ()
<br />
&nbsp;&nbsp;(let ((x (gensym)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(equal x x)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;)
<br />
? (?1)
<br />
T
<br />
<br /><br /><br /><br /><br />(defun next-programme-avec-nouvelle-var (p)
<br />
&nbsp;&nbsp;(subst (gentemp) 'x (next-programme (remettre-x p)))
<br />
&nbsp;&nbsp;)
<br />
? (e '((LAMBDA (T25) (EQUAL T25 T25)) 'a) en)
<br />
T
<br />
<br /><br /><br /><br />(defun next-programme-avec-nouvelle-var (p)
<br />
&nbsp;&nbsp;(subst (gensym) 'x (next-programme (remettre-x p)))
<br />
&nbsp;&nbsp;)
<br />
? (e '((LAMBDA (#:G234) (EQUAL #:G234 #:G234)) 'a) en)
<br />
<br />(ERREUR #:G234 C-EST-QUOI-?)
<br />
<br /><br /><br /><br />LA MORALE : ON N'A PAS LE PROBLEME AVEC GENTEMP :
<br />
<br /><br />? 
<br />
(defun test-npanv ()
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a '(lambda (x) x))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-panv a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b)))
<br />
TEST-NPANV
<br />
? (test-npanv)
<br />
<br />(LAMBDA (T2) 'EQUAL) 
<br />
(LAMBDA (T3) 'CAR) 
<br />
(LAMBDA (T4) 'CDR) 
<br />
(LAMBDA (T5) (CAR T5)) 
<br />
(LAMBDA (T6) (CDR T6)) 
<br />
(LAMBDA (T7) 'T7) 
<br />
(LAMBDA (T8) (K T8)) 
<br />
(LAMBDA (T9) (NULL T9)) 
<br />
(LAMBDA (T10) 'QUOTE) 
<br />
(LAMBDA (T11) 'LAMBDA) 
<br />
(LAMBDA (T12) 'K) 
<br />
(LAMBDA (T13) 'CONS) 
<br />
(LAMBDA (T14) 'COND) 
<br />
(LAMBDA (T15) 'NULL) 
<br />
(LAMBDA (T16) '(EQUAL)) 
<br />
(LAMBDA (T17) '(CAR)) 
<br />
(LAMBDA (T18) '(CDR)) 
<br />
(LAMBDA (T19) '(T19)) 
<br />
(LAMBDA (T20) '(QUOTE)) 
<br />
(LAMBDA (T21) '(LAMBDA)) 
<br />
(LAMBDA (T22) '(K)) 
<br />
(LAMBDA (T23) '(CONS)) 
<br />
(LAMBDA (T24) '(COND)) 
<br />
(LAMBDA (T25) '(NULL)) 
<br />
(LAMBDA (T26) (EQUAL T26 T26)) 
<br />
(LAMBDA (T27) (CONS T27 T27)) 
<br />
Aborted
<br />
? ((LAMBDA (T26) (EQUAL T26 T26)) 'a)
<br />
T
<br />
? (e '((LAMBDA (T5) (CAR T5)) '(ef gr)) en)
<br />
EF
<br />
<br /><br />j'ai modifié : next-panv part de nil :
<br />
? (defun test-npanv ()
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a NIL)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-panv a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b)))
<br />
TEST-NPANV
<br />
? (test-npanv)
<br />
<br />(LAMBDA (X) X)         correct : la première variable ne doit pas être renommée
<br />
(LAMBDA (T24) 'EQUAL)  correct gentemp a déjà été utilisé lors de la pre-
<br />
(LAMBDA (T25) 'CAR)    mière session.
<br />
(LAMBDA (T26) 'CDR) 
<br />
(LAMBDA (T27) (CAR T27)) 
<br />
(LAMBDA (T28) (CDR T28)) 
<br />
(LAMBDA (T29) 'T29) 
<br />
(LAMBDA (T30) (K T30)) 
<br />
(LAMBDA (T31) (NULL T31)) 
<br />
(LAMBDA (T32) 'QUOTE) 
<br />
(LAMBDA (T33) 'LAMBDA) 
<br />
(LAMBDA (T34) 'K) 
<br />
(LAMBDA (T35) 'CONS) 
<br />
(LAMBDA (T36) 'COND) 
<br />
(LAMBDA (T37) 'NULL) 
<br />
(LAMBDA (T38) '(EQUAL)) 
<br />
(LAMBDA (T39) '(CAR)) 
<br />
(LAMBDA (T40) '(CDR)) 
<br />
(LAMBDA (T41) '(T41)) 
<br />
(LAMBDA (T42) '(QUOTE)) 
<br />
(LAMBDA (T43) '(LAMBDA)) 
<br />
(LAMBDA (T44) '(K)) 
<br />
(LAMBDA (T45) '(CONS)) 
<br />
(LAMBDA (T46) '(COND)) 
<br />
(LAMBDA (T47) '(NULL)) 
<br />
(LAMBDA (T48) (EQUAL T48 T48)) 
<br />
(LAMBDA (T49) (CONS T49 T49)) 
<br />
Aborted
<br />
<br />? (next-triple nil)
<br />
(1 1 1)
<br />
? (next-panv nil)
<br />
(LAMBDA (X) X)
<br />
? (next-panv '(LAMBDA (X) X))
<br />
(LAMBDA (T51) 'EQUAL)
<br />
? (next-data nil)
<br />
'EQUAL
<br />
<br /><br />4.4.2 DU  (dovetelleur universel)
<br />
<br />bijection entre w et w3 : NEXT TRIPLE (19 2 91)
<br />
<br />need F-lisp &amp; F-dove (UT LI DO IS)
<br />
<br />Next-triple      (triple de nombres)
<br />
<br />(defun next-triple (triple)
<br />
&nbsp;&nbsp;(cond 
<br />
&nbsp;&nbsp;&nbsp;((null triple) '(1 1 1))
<br />
&nbsp;&nbsp;&nbsp;((and (equal (cadr triple) 1)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(equal (caddr triple) 1))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(list 1 1 (+ 1 (car triple))))
<br />
&nbsp;&nbsp;&nbsp;((equal (caddr triple) 1)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(list (+ 1 (car triple))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(- (cadr triple) 1)))
<br />
&nbsp;&nbsp;&nbsp;(t (list (car triple)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+ 1 (cadr triple))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(- (caddr triple) 1))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;)
<br />
<br /><br />? (next-triple nil)
<br />
(1 1 1)
<br />
? (next-triple '(1 1 1))
<br />
(1 1 2)
<br />
? (next-triple '(1 1 2))
<br />
(1 2 1)
<br />
? (next-triple '(1 2 1))
<br />
(2 1 1)
<br />
? (next-triple '(2 1 1))
<br />
(1 1 3)
<br />
? (next-triple '(1 1 3))
<br />
(1 2 2)
<br />
? 
<br />
<br />next-mémoire
<br />
<br />(defun next-mémoire (mémoire)
<br />
&nbsp;&nbsp;(let ((x (next-triple (car mémoire))))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(cond 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal x '(1 1 1)) (cons x nil))     pour éviter NIL dans la mémoire
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;depuis que next-triple part de nil
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((nouvelle-execution x) (cons x mémoire))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t (cons x (del-derniere-éxécution x mémoire)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;)
<br />
<br />plus tard enlevé les éxécutions arrêtées (EEA) : (t (EEA (rempl ...)
<br />
<br />(defun nouvelle-éxécution (triple)    plus tard avec triplet
<br />
&nbsp;&nbsp;(equal (caddr triple) 1)
<br />
&nbsp;&nbsp;)
<br />
<br />(defun del-derniere-éxécution (x mémoire)  x = la derniere éxécution
<br />
&nbsp;&nbsp;(cond 
<br />
&nbsp;&nbsp;&nbsp;((null mémoire) nil)
<br />
&nbsp;&nbsp;&nbsp;((equal (list (car x) (cadr x))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list (caar mémoire) (cadar mémoire))) 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(cdr mémoire))
<br />
&nbsp;&nbsp;&nbsp;(t (cons (car mémoire) (del-derniere-éxécution x (cdr mémoire)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;)
<br />
<br /><br />test
<br />
<br />(defun ttt ()    teste la suite infinie des triples (Test Tous les Triples)
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a '())
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-triple a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b))
<br />
&nbsp;)
<br />
<br />(defun ttm () teste la suite infinie des mémoires (Test Toutes les Mémoires)
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a '(()))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pprint a)  (print (length a)) (terpri)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-mémoire a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pprint a) (print (length a)) (terpri)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b))       )          
<br />
<br /><br /><br /><br />éxécution (détail)
<br />
<br />TTM
<br />
? (ttm)
<br />
<br />((1 1 1))
<br />
1 
<br />
<br />((1 1 2))
<br />
1 
<br />
<br />((1 2 1) (1 1 2))
<br />
2 
<br />
<br />((2 1 1) (1 2 1) (1 1 2))
<br />
3 
<br />
<br />((1 1 3) (2 1 1) (1 2 1))
<br />
3 
<br />
<br />((1 2 2) (1 1 3) (2 1 1))
<br />
3 
<br />
<br />((1 3 1) (1 2 2) (1 1 3) (2 1 1))
<br />
4 
<br />
<br />((2 1 2) (1 3 1) (1 2 2) (1 1 3))
<br />
4 
<br />
<br />((2 2 1) (2 1 2) (1 3 1) (1 2 2) (1 1 3))
<br />
5 
<br />
<br />((3 1 1) (2 2 1) (2 1 2) (1 3 1) (1 2 2) (1 1 3))
<br />
6 
<br />
<br />((1 1 4) (3 1 1) (2 2 1) (2 1 2) (1 3 1) (1 2 2))
<br />
6 
<br />
<br />((1 2 3) (1 1 4) (3 1 1) (2 2 1) (2 1 2) (1 3 1))
<br />
6 
<br />
<br />((1 3 2) (1 2 3) (1 1 4) (3 1 1) (2 2 1) (2 1 2))
<br />
6 
<br />
<br />((1 4 1) (1 3 2) (1 2 3) (1 1 4) (3 1 1) (2 2 1) (2 1 2))
<br />
7 
<br />
<br />((2 1 3) (1 4 1) (1 3 2) (1 2 3) (1 1 4) (3 1 1) (2 2 1))
<br />
7 
<br />
<br />((2 2 2) (2 1 3) (1 4 1) (1 3 2) (1 2 3) (1 1 4) (3 1 1))
<br />
7 
<br />
<br />((2 3 1) (2 2 2) (2 1 3) (1 4 1) (1 3 2) (1 2 3) (1 1 4) (3 1 1))
<br />
8 
<br />
<br />((3 1 2) (2 3 1) (2 2 2) (2 1 3) (1 4 1) (1 3 2) (1 2 3) (1 1 4))
<br />
8 
<br />
<br />((3 2 1) (3 1 2) (2 3 1) (2 2 2) (2 1 3) (1 4 1) (1 3 2) (1 2 3) (1 1 4))
<br />
9 
<br />
<br />...
<br />
<br />&nbsp;
<br />
((9 5 3) (9 4 4) (9 3 5) (9 2 6) (9 1 7) (8 8 1) (8 7 2) (8 6 3) (8 5 4) (8 4 5)
<br />
&nbsp;(8 3 6) (8 2 7) (8 1 8) (7 9 1) (7 8 2) (7 7 3) (7 6 4) (7 5 5) (7 4 6) (7 3 7)
<br />
&nbsp;(7 2 8) (7 1 9) (6 10 1) (6 9 2) (6 8 3) (6 7 4) (6 6 5) (6 5 6) (6 4 7)
<br />
&nbsp;(6 3 8) (6 2 9) (6 1 10) (5 11 1) (5 10 2) (5 9 3) (5 8 4) (5 7 5) (5 6 6)
<br />
&nbsp;(5 5 7) (5 4 8) (5 3 9) (5 2 10) (5 1 11) (4 12 1) (4 11 2) (4 10 3) (4 9 4)
<br />
&nbsp;(4 8 5) (4 7 6) (4 6 7) (4 5 8) (4 4 9) (4 3 10) (4 2 11) (4 1 12) (3 13 1)
<br />
&nbsp;(3 12 2) (3 11 3) (3 10 4) (3 9 5) (3 8 6) (3 7 7) (3 6 8) (3 5 9) (3 4 10)
<br />
&nbsp;(3 3 11) (3 2 12) (3 1 13) (2 14 1) (2 13 2) (2 12 3) (2 11 4) (2 10 5) (2 9 6)
<br />
&nbsp;(2 8 7) (2 7 8) (2 6 9) (2 5 10) (2 4 11) (2 3 12) (2 2 13) (2 1 14) (1 15 1)
<br />
&nbsp;(1 14 2) (1 13 3) (1 12 4) (1 11 5) (1 10 6) (1 9 7) (1 8 8) (1 7 9) (1 6 10)
<br />
&nbsp;(1 5 11) (1 4 12) (1 3 13) (1 2 14) (1 1 15) (14 1 1) (13 2 1) (13 1 2)
<br />
&nbsp;(12 3 1) (12 2 2) (12 1 3) (11 4 1) (11 3 2) (11 2 3) (11 1 4) (10 5 1)
<br />
&nbsp;(10 4 2) (10 3 3) (10 2 4) (10 1 5) (9 6 1))
<br />
113
<br />
<br />Remarquons que next-mémoire ne sera jamais utilisé tel quel, il sert de caricature à next-me-mp-md.
<br />
<br /><br /><br /><br />Recherche ou création des programmes (donnée) lors du dovetellage : ROC
<br />
<br />Le dovetelleur trimbale la mémoire des programmes créés, ainsi que des données créées, ainsi que des éxécutions déjà effectuées a fin de ne pas calculer deuxfois la même chose.
<br />
ME = mémoire des éxécutions, c'est essentiellement la MEMOIRE de plus haut dans
<br />
laquelle on inclu le résultat des éxécutions (partielles) obtenues.
<br />
MP = la mémoire des programmes générés.
<br />
MD = la mémoire des données générées.
<br />
L'argument de NEXT-ME-MP-MD est la liste &lt;ME,MP,MD&gt; donc :
<br />
<br /><br />(defun select-me (me-mp-md)
<br />
&nbsp;&nbsp;(car me-mp-md)
<br />
&nbsp;&nbsp;)
<br />
<br />(defun select-mp (me-mp-md)
<br />
&nbsp;&nbsp;(cadr me-mp-md)
<br />
&nbsp;&nbsp;)
<br />
<br />(defun select-md (me-mp-md)
<br />
&nbsp;&nbsp;(caddr me-mp-md)
<br />
&nbsp;&nbsp;)
<br />
<br /><br />A présent il faut une routine capable de chercher un programme (resp. une 
<br />
donnée) en mémoire et de le (resp. la) créer s'il ne trouve pas ce dernier 
<br />
(resp. cette dernière).
<br />
<br />la forme de MP est du genre : ((5 P5) (1 P1) (3 P3) (2 P2)) sans ordre
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MD                ((1 D1) (7 D7))          ...
<br />
<br />(la forme de ME : (&lt;triple&gt; &lt;éxéc&gt; &lt;triple&gt; &lt;éxéc&gt; ...)   ).
<br />
<br /><br />A fin de pouvoir utiliser directement le résultat d'un ROC, ce dernier place
<br />
en tête son résultat dans MP (resp. MD).
<br />
<br />ainsi (ROC 5 ((2 P2)(5 P5)(1 P1)) ) donne ((5 P5)(2 P2)(1 P1))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ROC 6 ((2 P2)(5 P5)(1 P1)) ) donne ((6 P6)(5 P5)(2 P2)(1 P1)).
<br />
<br />où Pi est le ième programme.
<br />
ROC utilise des mémoires auxiliaires à fin d'éviter de parcourir plusieur fois
<br />
la mémoire.
<br />
<br /><br /><br />(defun roc (n m pvd) n = le numéro (donné par le triple généré)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = la mémoire des programmes (MP) ou des données (MD), le
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;même ROC cherche les deux (=&gt; appel de EVAL)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pvd = NEXT-PANV ou NEXT-DATA. (dans GEN (P&amp;D)).
<br />
&nbsp;&nbsp;(cond ((null m)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons (list 1 (eval (list pvd nil)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal n (caar m)) m) facilite la vie de ROC-AUX
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(T (roc-aux n nil m nil pvd))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;)
<br />
<br /><br /><br />dans (roc-aux n nil m nil pvd) le premier nil = ce qui à déjà été parcouru dans
<br />
la mémoire, c'est le AUX de roc-aux, le second NIL est un emplacement pour
<br />
retenir le programme N-1 au cas où on ne trouve pas le programme N, à fin de 
<br />
ne pas devoir reparcourir la mémoire pour trouver ce PN-1 à partir duquel on 
<br />
va créer PN.(ou DN-1)
<br />
<br /><br />(defun roc-aux (n aux m PvD-N-1 pvd)
<br />
&nbsp;&nbsp;(cond
<br />
&nbsp;&nbsp;&nbsp;((null m)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(cons (list n
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval (list pvd (list 'quote PvD-N-1)))) pas sûr
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aux)) m a été entièrement parcouru, PvD-N-1 a du être instancier.
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attention on elève les éxécutions arrêtées, mais cela ne touche
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ni MP, ni MD.
<br />
&nbsp;&nbsp;&nbsp;((equal n (caar m))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(cons (list n (cadar m))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append aux (cdr m)))) on évite le parcours inutil d'un del-assoc
<br />
&nbsp;&nbsp;&nbsp;((equal (- n 1) (caar m))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(roc-aux n 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons (car m) aux) 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr m) 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cadar m) on retient en passant le PvD-N-1
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pvd)) 
<br />
&nbsp;&nbsp;&nbsp;(T (roc-aux n (cons (car m) aux) (cdr m) PvD-N-1 pvd))
<br />
&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;)
<br />
<br /><br /><br /><br /><br />essai (next-panv et next-data proviennent de GEN (P&amp;D).)
<br />
? (roc 1 nil 'next-panv)
<br />
((1 (LAMBDA (X) X)))
<br />
? (roc 1 nil 'next-data)
<br />
((1 'EQUAL))
<br />
? (roc 2 '((1 (LAMBDA (X) X))) 'next-panv)
<br />
((2 (LAMBDA (T56) 'EQUAL)) (1 (LAMBDA (X) X)))
<br />
? (roc 1 '((1 (LAMBDA (X) X))) 'next-panv)
<br />
((1 (LAMBDA (X) X)))
<br />
? (roc 1 '((2 (LAMBDA (T54) 'EQUAL)) (1 (LAMBDA (X) X))) 'next-panv)
<br />
((1 (LAMBDA (X) X)) (2 (LAMBDA (T54) 'EQUAL)))
<br />
<br />notons que (roc 3 nil &quot;pvd&quot;) n'est pas censé fonctionner on utilise le fait
<br />
que NEXT-ME-MP-MD part de (roc 1 nil &quot;pvd&quot;) si bien qu'il n'est nécessaire de
<br />
créer un Pn seulement lorsque Pn-1 a déjà été créé.
<br />
<br /><br />remarquons que ROC fonctionne avec next-data, next-programme (next-panv), mais 
<br />
DU va fonctionner avec ROC parce que next-panv gère le processus de renommage 
<br />
des variables. Si on utilise DU sur un autre générateur de programmes, il 
<br />
convient de s'assurer que ce générateur renomme les variables. On peut aussi 
<br />
modifier le dovetaileur de telle façon qu'il gère lui-même le renommage.
<br />
<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
<br /><br />next-mémoire-programme-donnée
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NEXT-ME-MP-MD
<br />
<br /><br />Next-me-mp-md doit utilise next-triple et s'inspire de next-memoire pour 
<br />
mémoriser les éxécutions de façon parsimonieuse. Il utilise ROC pour la 
<br />
gestion des mémoires de programmes et de données respectivement.
<br />
<br />need GEN (P&amp;D) (notamment next-programme (next-panv) et next-data)
<br />
need E-step, donc dove (et donc E, donc tout UT LI DO IS)
<br />
<br />le me-mp-md initial sera ((nil) nil nil).
<br />
<br /><br /><br />(defun next-me-mp-md (me-mp-md)
<br />
&nbsp;&nbsp;(let* (                            n- et a- = nouveau et ancien resp.
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a-me (select-me me-mp-md))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x (next-triple (car (select-me me-mp-md))))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(n-mp (roc (car x) (select-mp me-mp-md) 'next-panv)) (mi à jo de mp)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(n-md (roc (cadr x) (select-md me-mp-md) 'next-data)) (mi à jo de md)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;mise à jour de me (qui est plus délicate) s'inspire de next-mémoire
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(cond ((nouvelle-éxécution x)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list (cons x (cons (a-step (cadar n-mp)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list (cadar n-md)) en) (car me-mp-md)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n-mp
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n-md))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(T 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list (cons x       ajout du triple
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons                 ajout de sa réalisation
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e-step (recherche-éxéc x a-me) en)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(del-dernière-éxécution x
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cette dernière routine doit être modifier
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;à cause de la présence explicite des éxéc.
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a-me)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n-mp
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n-md))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;)
<br />
<br />EEA inutile puisqu'on enlève le chemin, et il faut garder la toute dernière 
<br />
éxécution (de terminaison) de façon telle que lorsque le triple suivant est 
<br />
généré next-me-mp-md ne cherche pas l'éxécution suivante.
<br />
<br />(defun recherche-éxéc (triple me)
<br />
&nbsp;&nbsp;(cond ((null me) (print 'erreur))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal (list (car triple) (cadr triple))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list (caar me) (cadar me)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cadr me))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t (recherche-éxéc triple (cddr me)))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;)
<br />
<br />remarquons que recherche-éxéc ne cherche pas la dernière éxécution, c-à-d il ne compare pas le 3ième élément du triple. Il tient compte du fait que next-me-mp-md nettoie me pour ne laisser que les dernières éxécutions (avec del-dernière-éxécution).
<br />
<br />Ce programme est le même que celui utilisé dans next-mémoire à deux détails près : son nom (bien sûr) l'accent est mis sur dernière. (diff. de derniere) sa fonction ? enlève le triple ET le résultat (qui suit le triple),mais se plantera si une éxécution n'est pas une liste.
<br />
Rappelons que me est la même chose que mémoire avec les éxécutions placées derriere chaque triples. (à tester)
<br />
<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br />
(defun del-dernière-éxécution (x me)  x = la dernière éxécution
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;me = mémoire éxécution
<br />
&nbsp;&nbsp;(cond 
<br />
&nbsp;&nbsp;&nbsp;((null me) nil)
<br />
&nbsp;&nbsp;&nbsp;((equal (list (car x) (cadr x))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list (caar me) (cadar me))) 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;(cddr me))
<br />
&nbsp;&nbsp;&nbsp;(t (cons (car me) (cons (cadr me) (del-dernière-éxécution x (cddr me))))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;)
<br />
<br /><br />dans EEA je suppose aussi que toutes les éxécutions sont des listes :
<br />
il doit aussi enlever le triple précédent ! (ce n'est pas encore fait).
<br />
<br />(defun EEA (me)
<br />
&nbsp;&nbsp;(cond ((null me) nil)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal (caar me) 'val) (EEA (cdr me))) cf e-step
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(T (cons (car me) (EEA (cdr me))))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
<br />
&nbsp;&nbsp;)
<br />
<br /><br /><br /><br />un dovetelleur universel : DU
<br />
<br /><br />&lt;ne pas oublier renomme-var&gt; : ici le générateur (next-panv) de programmes s'en occupe.
<br />
<br />gestion des sorties
<br />
<br /><br />(defun print-me-mp-md (m) sans détails
<br />
&nbsp;&nbsp;(print-triple (caar m))
<br />
&nbsp;&nbsp;(print (cadar m))
<br />
&nbsp;&nbsp;(terpri)
<br />
)
<br />
<br /><br />(defun print-triple (tr)
<br />
&nbsp;&nbsp;(print (list 'programme (car tr)))
<br />
&nbsp;&nbsp;(print (list 'donnee (cadr tr)))
<br />
&nbsp;&nbsp;(print (list 'etape (caddr tr)))
<br />
&nbsp;&nbsp;)
<br />
<br /><br />(defun print-me-mp-md-avec-détail (m) 
<br />
&nbsp;&nbsp;(print '----------------------------------------------------------)
<br />
&nbsp;&nbsp;(print (list 'programme (car (caar m)) '******* (cadar (select-mp m))))
<br />
&nbsp;&nbsp;(print (list 'donnee (cadr (caar m)) '******* (cadar (select-md m))))
<br />
&nbsp;&nbsp;(print (list 'execution (caddr (caar m)) '******* (cadr (select-me m))))
<br />
&nbsp;&nbsp;(print '----------------------------------------------------------)
<br />
&nbsp;&nbsp;(terpri)
<br />
)
<br />
<br /><br />(defun print-me-mp-md-avec-tous-les-détails (m) 
<br />
&nbsp;&nbsp;(print '----------------------------------------------------------)
<br />
&nbsp;&nbsp;(pprint m) (terpri)
<br />
&nbsp;&nbsp;(print (list 'programme (car (caar m)) '******* (cadar (select-mp m))))
<br />
&nbsp;&nbsp;(print (list 'donnee (cadr (caar m)) '******* (cadar (select-md m))))
<br />
&nbsp;&nbsp;(print (list 'execution (caddr (caar m)) '******* (cadr (select-me m))))
<br />
&nbsp;&nbsp;(print '----------------------------------------------------------)
<br />
&nbsp;&nbsp;(terpri) (terpri)
<br />
)
<br />
<br /><br /><br /><br /><br /><br /><br /><br />DUs
<br />
<br />(defun du ()
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a '((nil)()())) le me-mp-md initial ne sera pas imprimé
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-me-mp-md a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print-me-mp-md-avec-détail a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b))
<br />
&nbsp;)
<br />
<br /><br />(defun du-rapide ()
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a '((nil)()())) le me-mp-md initial ne sera pas imprimé
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-me-mp-md a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print-me-mp-md a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b))
<br />
&nbsp;)
<br />
<br /><br />(defun du-lent ()
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a '((nil)()())) le me-mp-md initial ne sera pas imprimé
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-me-mp-md a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print-me-mp-md-avec-tous-les-détails a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b))
<br />
&nbsp;)
<br />
<br /><br />(defun du-très-rapide ()
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a '((nil)()())) le me-mp-md initial ne sera pas imprimé
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-me-mp-md a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let ((me (select-me a))) 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print (list (car me) '+++++++ (cadr me))))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b))
<br />
&nbsp;)
<br />
<br /><br />(defun du-express ()
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a '((nil)()())) le me-mp-md initial ne sera pas imprimé
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-me-mp-md a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond ((equal (caadar a) 'val) (go b))) 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let ((me (select-me a))) 
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print (list (car me) '+++++++ (cadr me))))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b))
<br />
&nbsp;)
<br />
<br /><br />(defun du-muet ()          ne sort rien (mais rêve-t-il ?)
<br />
&nbsp;(prog (a)
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(setq a '((nil)()())) le me-mp-md initial ne sera pas imprimé
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (setq a (next-me-mp-md a))
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(go b))
<br />
&nbsp;)
<br />
<br /><br /><br />============================= EXECUTION===============================
<br />
éxécution
<br />
<br />? (du)
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 1 ******* (LAMBDA (X) X)) 
<br />
(DONNEE 1 ******* 'EQUAL) 
<br />
(EXECUTION 1 ******* 'EQUAL) 
<br />
---------------------------------------------------------- 
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 1 ******* (LAMBDA (X) X)) 
<br />
(DONNEE 1 ******* 'EQUAL) 
<br />
(EXECUTION 2 ******* (VAL EQUAL)) 
<br />
---------------------------------------------------------- 
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 1 ******* (LAMBDA (X) X)) 
<br />
(DONNEE 2 ******* 'CAR) 
<br />
(EXECUTION 1 ******* 'CAR) 
<br />
---------------------------------------------------------- 
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 2 ******* (LAMBDA (T0) 'EQUAL)) 
<br />
(DONNEE 1 ******* 'EQUAL) 
<br />
(EXECUTION 1 ******* 'EQUAL) 
<br />
---------------------------------------------------------- 
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 1 ******* (LAMBDA (X) X)) 
<br />
(DONNEE 1 ******* 'EQUAL) 
<br />
(EXECUTION 3 ******* (VAL EQUAL)) 
<br />
---------------------------------------------------------- 
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 1 ******* (LAMBDA (X) X)) 
<br />
(DONNEE 2 ******* 'CAR) 
<br />
(EXECUTION 2 ******* (VAL CAR)) 
<br />
---------------------------------------------------------- 
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 1 ******* (LAMBDA (X) X)) 
<br />
(DONNEE 3 ******* 'CDR) 
<br />
(EXECUTION 1 ******* 'CDR) 
<br />
---------------------------------------------------------- 
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 2 ******* (LAMBDA (T0) 'EQUAL)) 
<br />
(DONNEE 1 ******* 'EQUAL) 
<br />
(EXECUTION 2 ******* (VAL EQUAL)) 
<br />
---------------------------------------------------------- 
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 2 ******* (LAMBDA (T0) 'EQUAL)) 
<br />
(DONNEE 2 ******* 'CAR) 
<br />
(EXECUTION 1 ******* 'EQUAL) 
<br />
---------------------------------------------------------- 
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 3 ******* (LAMBDA (T1) 'CAR)) 
<br />
(DONNEE 1 ******* 'EQUAL) 
<br />
(EXECUTION 1 ******* 'CAR) 
<br />
---------------------------------------------------------- 
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 1 ******* (LAMBDA (X) X)) 
<br />
(DONNEE 1 ******* 'EQUAL) 
<br />
(EXECUTION 4 ******* (VAL EQUAL)) 
<br />
---------------------------------------------------------- 
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 1 ******* (LAMBDA (X) X)) 
<br />
(DONNEE 2 ******* 'CAR) 
<br />
(EXECUTION 3 ******* (VAL CAR)) 
<br />
---------------------------------------------------------- 
<br />
<br />---------------------------------------------------------- 
<br />
(PROGRAMME 1 ******* (LAMBDA (X) X)) 
<br />
(DONNEE 3 ******* 'CDR) 
<br />
(EXECUTION 2 ******* (VAL CDR)) 
<br />
---------------------------------------------------------- 
<br />
<span id="received"><dfn>Received on</dfn> Thu May 03 2001 - 02:23:12 PDT</span>
</div>
<!-- body="end" -->
<div class="foot">
<map id="navbarfoot" name="navbarfoot" title="Related messages">
<ul class="links">
<li><dfn>This message</dfn>: [ <a href="#start2821">Message body</a> ]</li>
<!-- lnext="start" -->
<li><dfn>Next message</dfn>: <a href="2822.html" title="Next message in the list">Marchal: "Re: The role of logic, &#0038; planning ..."</a></li>
<li><dfn>Previous message</dfn>: <a href="2820.html" title="Previous message in the list">Marchal: "Re: Belief &#0038; Knowledge"</a></li>
<li><dfn>Maybe in reply to</dfn>: <a href="2814.html" title="Message to which this message replies">hal.domain.name.hidden: "Program for UD"</a></li>
<!-- lnextthread="start" -->
<li><dfn>Next in thread</dfn>: <a href="2829.html" title="Next message in this discussion thread">Marchal: "Re: Program for UD"</a></li>
<!-- lreply="end" -->
</ul>
<ul class="links">
<li><a name="options3" id="options3"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg2821" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg2821" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg2821" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg2821" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</map>
</div>
<!-- trailer="footer" -->
<p><small><em>
This archive was generated by <a href="http://www.hypermail-project.org/">hypermail 2.3.0</a>
: Fri Feb 16 2018 - 13:20:07 PST
</em></small></p>
</body>
</html>
