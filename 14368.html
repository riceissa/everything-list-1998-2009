<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<meta name="generator" content="hypermail 2.3.0, see http://www.hypermail-project.org/" />
<title>SUMMARY (was: OM = SIGMA_1) from Bruno Marchal on 2008-01-18 (everything)</title>
<meta name="Author" content="Bruno Marchal (marchal.domain.name.hidden)" />
<meta name="Subject" content="SUMMARY (was: OM = SIGMA_1)" />
<meta name="Date" content="2008-01-18" />
<style type="text/css">
/*<![CDATA[*/
/* To be incorporated in the main stylesheet, don't code it in hypermail! */
body {color: black; background: #ffffff}
dfn {font-weight: bold;}
pre { background-color:inherit;}
.head { border-bottom:1px solid black;}
.foot { border-top:1px solid black;}
th {font-style:italic;}
table { margin-left:2em;}map ul {list-style:none;}
#mid { font-size:0.9em;}
#received { float:right;}
address { font-style:inherit ;}
/*]]>*/
.quotelev1 {color : #990099}
.quotelev2 {color : #ff7700}
.quotelev3 {color : #007799}
.quotelev4 {color : #95c500}
.period {font-weight: bold}
</style>
</head>
<body>
<div class="head">
<h1>SUMMARY (was: OM = SIGMA_1)</h1>
<!-- received="Fri Jan 18 11:04:17 2008" -->
<!-- isoreceived="20080118190417" -->
<!-- sent="Fri, 18 Jan 2008 17:04:05 +0100" -->
<!-- isosent="20080118160405" -->
<!-- name="Bruno Marchal" -->
<!-- email="marchal.domain.name.hidden" -->
<!-- subject="SUMMARY (was: OM = SIGMA_1)" -->
<!-- id="ee259a9f53cd4c7d180beecb339f10cd.domain.name.hidden" -->
<!-- charset="ISO-8859-1" -->
<!-- inreplyto="479002d4.3ff8220a.0ab0.fffffc16SMTPIN_ADDED.domain.name.hidden" -->
<!-- expires="-1" -->
<map id="navbar" name="navbar">
<ul class="links">
<li>
<dfn>This message</dfn>:
[ <a href="#start14368" name="options1" id="options1" tabindex="1">Message body</a> ]
 [ More options (<a href="#options2">top</a>, <a href="#options3">bottom</a>) ]
</li>
<li>
<dfn>Related messages</dfn>:
<!-- unext="start" -->
[ <a href="14369.html" accesskey="d" title="Russell Standish: &quot;Re: What has Schmidhuber been up to&quot;">Next message</a> ]
[ <a href="14367.html" title="George Levy: &quot;Re: dark energy&quot;">Previous message</a> ]
[ <a href="14366.html" title="Hal Ruhl: &quot;Re: dark energy&quot;">In reply to</a> ]
<!-- unextthread="start" -->
[ <a href="14383.html" accesskey="t" title="Mirek Dobsicek: &quot;Re: SUMMARY&quot;">Next in thread</a> ]
 [ <a href="#replies">Replies</a> ]
<!-- ureply="end" -->
</li>
</ul>
</map>
<ul class="links">
<li><a name="options2" id="options2"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg14368" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg14368" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg14368" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg14368" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</div>
<!-- body="start" -->
<div class="mail">
<address class="headers">
<span id="from">
<dfn>From</dfn>: Bruno Marchal &lt;<a href="mailto:marchal.domain.name.hidden?Subject=Re%3A%20SUMMARY%20(was%3A%20OM%20%3D%20SIGMA_1)">marchal.domain.name.hidden</a>&gt;
</span><br />
<span id="date"><dfn>Date</dfn>: Fri, 18 Jan 2008 17:04:05 +0100</span><br />
</address>
<br />
Title: SUMMARY (was: OM = SIGMA_1)
<br />
<br />I send to David Nyman (the 06 Nov 2007) a little planning:
<br />
<br />1) Cantor's diagonal
<br />
2) Does the universal digital machine exist?
<br />
3) Lobian machines,  who and what are they?
<br />
4) The 1-person and the 3- machine.
<br />
5) Lobian machines' theology
<br />
6) Lobian machines' physics
<br />
7) Lobian machines' ethics
<br />
<br /><br />Let me summarize what has been done and what remains to be done.
<br />
<br /><br />1) Cantor's diagonal
<br />
<br />I tend to consider that the point &quot;1)&quot; is finished. Cantor's argument 
<br />
is that if there is a bijection between natural numbers, that is: 0, 1, 
<br />
2, 3, 4, ..., and sequences of numbers, that is a bijection like
<br />
<br />0 ----------- 45, 7, 8976, 4, 32, ...
<br />
1 ----------- 0,   0,   67,   78, 0, ...
<br />
2 ----------- 27, 1,  24,   24,  23, ...
<br />
3 ----------- 1,   1,   1,   345,  7,  ...
<br />
...
<br />
<br />then the &quot;antidiagonal&quot; sequence 46, 1, 25, 346, ...  cannot be in the 
<br />
list, because by construction it differs from each sequence in the 
<br />
list. See below how to make explicit the contradiction.
<br />
The reasoning does not depend on the particular sequences exhibited, 
<br />
and it shows that no enumerable set of sequences can be put in 1-1 
<br />
correspondence with the natural numbers. The conclusion is that the set 
<br />
of all sequences of natural numbers is innumerable (not enumerable, not 
<br />
countable, uncountable, etc. Important concept have many synonym in 
<br />
math).
<br />
<br />Let me recall the same proof, but with usual mathematical notation.
<br />
A sequence of numbers, like f_0 =
<br />
<br />56, 7897876, 67, 89, 1, 1, 45, ...
<br />
<br />is really &quot;just&quot; a function from N to N:
<br />
<br />f_0(0), f_0(1) f_0(2), f_0(3), f_0(4), ...
<br />
<br />with here:  f_0(0) = 56, f_0(1) = 7897876, f_0(2) = 67, f_0(3) = 89, 
<br />
f_0(4) = 1, etc.
<br />
<br />So the bijection above becomes:
<br />
<br /><br />0 ----------- f_0 =  f_0(0), f_0(1) f_0(2), f_0(3), f_0(4), ...
<br />
1 ----------- f_1 =  f_1(0), f_1(1) f_1(2), f_1(3), f_1(4), ...
<br />
2 ----------- f_2 =  f_2(0), f_2(1) f_2(2), f_2(3), f_2(4), ...
<br />
3 ----------- f_3 = f_3(0), f_3(1) f_3(2), f_3(3), f_4(4), ...
<br />
...
<br />
<br />You can see that the diagonal sequence can be described by:
<br />
<br />f_0(0), f_1(1), f_2(2), .... f_n(n), ...
<br />
<br />Then the &quot;antidiagonal&quot; sequence (function) g is given by
<br />
<br />f_0(0)+1, f_1(1)+1, f_2(2)+1, .... f_n(n)+1, ...
<br />
<br /><br />That is: g(n) = f_n(n)+1 (definition of g)
<br />
<br />Now we can make the contradiction explicit. Suppose that g is in the 
<br />
list f_i. Then it exists a number k such that g = f_k. This means of 
<br />
course that for all numbers n we have g(n) = f_k(n). In particular g(k) 
<br />
= f_k(k). But by the definition of g: g applied on k
<br />
= g(k) = f_k(k)+1. Thus (by Leibniz identity rule):
<br />
<br />f_k(k) = f_k(k)+1
<br />
<br />Now, all f_i are functions from N to N, so they are defined on all 
<br />
natural numbers, so f_k(k) is a number. We have seen in high school 
<br />
that identical numbers can be subtract on both sides of an equation 
<br />
leading to
<br />
<br />0 = 1. (contradiction). Thus the f_i cannot enumerate all functions 
<br />
from N to N. We say:
<br />
N^N is innumerable.
<br />
<br />This was point &quot;1)&quot;. Hope it is ok for every one. Please be sure you 
<br />
get the point before proceeding.
<br />
<br /><br />2) Does the universal digital machine exist?
<br />
<br />I recall the informal notion of what is an (intuitively) computable 
<br />
function (from N to N). Def: A function f from N to N is computable if 
<br />
we can describe in some formal language L, in a finite way, how to 
<br />
compute, in a finite time, its value f(n) on each natural number n.
<br />
Def. I will call &quot;code of f&quot; such a description of how to compute f.
<br />
Def. A language L is said universal if all computable functions can be 
<br />
described in the language.
<br />
Def. A machine is universal if she understands a universal language, 
<br />
(and thus can indeed compute all computable functions from N to N, at 
<br />
least in Platonia, where &quot;Platonia&quot; is defined by a place where you can 
<br />
always ask and get more time and more space/memory: we don't put 
<br />
deadline to the (universal) machine.
<br />
<br />Church thesis is the statement that a universal language (and machine) 
<br />
exists, and indeed that in particular lambda-calculus provides such a 
<br />
universal language.
<br />
<br />Church's thesis is not obvious. Indeed, when Church &quot;defined&quot; the 
<br />
computable functions by those capable of being computed by a 
<br />
lambda-expression (a symbolic expression or code written in the 
<br />
lambda-calculus), Stephen Cole Kleene thought at first that a reasoning 
<br />
similar to Cantor's proof of the non enumerability of N^N (see above) 
<br />
could be made against Church's pretension.
<br />
<br />Kleene's reasoning is the following, and works for any pretension that 
<br />
there is a universal language (so we have not to even define what 
<br />
lambda-calculus). Indeed, suppose that there is a universal machine and 
<br />
thus a universal language in which all computable functions from N to N 
<br />
can be given a code. Now the set of codes in the language L is 
<br />
enumerable, being a subset of all possible expression written in the 
<br />
language (which we have seen to be enumerable). Thus there is an 
<br />
enumeration of all computable functions from N to N
<br />
<br />f_1, f_2, f_3, f_4, f_5, f_6, f_7, f_8, f_9, ...
<br />
<br />but then the &quot;antidiagonal&quot; function g defined by
<br />
<br />g(n) = f_n(n) + 1
<br />
<br />is computable, given that each f_n is computable, and that &quot;+1&quot; is a 
<br />
computable operation. But g cannot be in the list, for the same reason 
<br />
as above.
<br />
Now this cannot be a proof that the set of computable functions is not 
<br />
enumerable, given that the set of codes is obviously enumerable. So 
<br />
this looks like a proof by absurdo that there is no universal language, 
<br />
and thus no universal machine.
<br />
<br />The proof, nevertheless is wrong. It did presuppose that the universal 
<br />
language compute all functions from N to N and only that 
<br />
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Indeed to substract f_(k)(k) on both 
<br />
side of f_(k)(k) = f_(k)(k) + 1, f_k(k) has to be a number!!!!!!!
<br />
If f_k(k) is undefined (for example the interpretation by the universal 
<br />
machine of the code makes the machine non stopping) then the argument 
<br />
just doesn't go through!!!!
<br />
<br />So the possibility that there is a universal language remains intact. 
<br />
But now we know that the codes written in the possible universal 
<br />
language could correspond to object which are NOT function from N to N, 
<br />
but from some subset of N to N. Such &quot;function&quot; are called strictly 
<br />
partial function: they are not defined on each natural number. Such 
<br />
function can make the computer crashing (looping, running forever, non 
<br />
stopping, etc.). So you have to accept the universal machine can crash 
<br />
if you want her to be able to be universal. As I said: you cannot have 
<br />
both security and universality. Later security will play a role for the 
<br />
notion of first person, and universality will play a role for the 
<br />
notion of third person.
<br />
<br />Experimentally, this is what happens for lambda-calculus, FORTRAN, 
<br />
JAVA, C++, Lisp, SK-combinators, game-of-life, etc. With those language 
<br />
each corresponding g functions, will indeed crash the corresponding 
<br />
universal machine (codes, expressions) when applied on their own code. 
<br />
All known universal language have been shown equivalent: they define 
<br />
always exactly the same class of computable functions.
<br />
<br />&nbsp;From this you can infer immediately unsolvability and incompleteness of 
<br />
any effective theory about machines (and numbers). Indeed if L is 
<br />
universal, then you can enumerate the codes (and thus the corresponding 
<br />
partial functions) written in L:
<br />
<br />f_1, f_2, f_3, f_4, f_5, f_6, f_7, f_8, f_9, ...
<br />
<br />But here the f_i denotes partial functions. That is a mixture of 
<br />
strictly partial function and of total functions (partial function 
<br />
where the domain-definition subset is N itself and thus total = defined 
<br />
on all n, or put in another way they belongs to N^N.
<br />
<br />Absolute unsolvability result:
<br />
There is no machine capable of deciding when, given a description of a 
<br />
code in L, if that code is for a strictly partial functions or a total 
<br />
partial function.
<br />
Proof. If such a code exists then you can used it to extract 
<br />
mechanically from the enumeration
<br />
<br />f_1, f_2, f_3, f_4, f_5, f_6, f_7, f_8, f_9, ...
<br />
<br />a &quot;sub-enumeration&quot; of the total partial functions. But then you obtain 
<br />
an enumeration of all total computable function and only 
<br />
those!!!!!!!!!!!!
<br />
But this leads to a (always the same) contradiction (see above). QED.
<br />
<br />(Relative) Incompleteness result.
<br />
There is no correct theories about machines in which all statements can 
<br />
be proved.
<br />
Proof: if there was such a theory, you would be able to use it to 
<br />
construct a machine capable of deciding totality/strict-partiality of 
<br />
codes in L, contradicting the absolute unsolvability result. QED.
<br />
<br />Note in particular that this means that for *any* correct theory T 
<br />
there will be a particular true statement with the shape &quot;the ith 
<br />
expression in language L does code a total partial function&quot; which is 
<br />
undecidable in that theory. This explains why incompleteness is 
<br />
relative, because in the theory T', which is T'+ (as new axioms) the 
<br />
preceding true statement, obviously the statement becomes provable in 
<br />
one line (by a proof saying &quot;see the axiom&quot;. There is no equivalent of 
<br />
Church's thesis for provability!
<br />
<br />So you see that the first incompleteness theorem of Gödel is a simple 
<br />
consequence of Church thesis. Incompleteness is proved by a direct 
<br />
Cantor diagonalization done in the realm of computable partial 
<br />
functions.
<br />
<br />A question: what if we want, for some reason, be sure the universal 
<br />
computer will not crash. After all we could ask for security. I will 
<br />
not answer that question now, but thinking on this question will lead 
<br />
to a notion of first person, and will give a notion of 
<br />
sub-universality. Sub-universality is somehow the nearer you can go 
<br />
near universality without loosing security.
<br />
<br />More remains to be said, here of course. In particular, both in this 
<br />
list and in a course I'm giving at ULB(*) I have begun to provide 
<br />
example of universal language. It seems to help a lot some students.
<br />
<br />- Cutland-Shepherdson-Sturgis coffee-bar language
<br />
- SK-combinators
<br />
- Diophantine Polynomials
<br />
- Robinsonian (and Lobian) Machine
<br />
- LISP
<br />
<br /><br /><br /><br />Let me summarize roughly the other points:
<br />
<br /><br /><br />3) Lobian machines,  who and what are they?
<br />
<br /><br />Here I have to explain the fundamental nuances between computability 
<br />
and provability. We have already seen, just above, a very big 
<br />
difference. For computability we have a &quot;Church's thesis&quot; and thus a 
<br />
notion of universality, but we have none for provability. Having a 
<br />
theory, we can always build a more powerful theory. No theories can be 
<br />
provability-universal.
<br />
Now, nothing prevent *some* theory of being computability-universal, 
<br />
and indeed we can build such a theory from any formal logical 
<br />
specification of a universal language.
<br />
Such specifications will give our &quot;absolute ontic  TOE&quot;, and defines 
<br />
the absolute measure on the Observer Moments from which we will derive 
<br />
the physical laws (just to test such theories with the empirical 
<br />
facts).
<br />
But the physics will not belong to the &quot;absolute ontic TOE&quot;. Physics 
<br />
will appears to belong to the &quot;categorie de l'entendement&quot;' would say 
<br />
Kant, I mean physics appears as a particular view by internal observers 
<br />
appearing in the &quot;absolute ontic TOE&quot;.
<br />
We thus need an observer notion (if only to get the &quot;Observer Moments), 
<br />
and, as most of you already know, the observer will be the Lobian 
<br />
Machine. A lobian machine will be a universal machine knowing (in some 
<br />
weak sense) that she is universal. Such a machine will known to be 
<br />
incomplete and will (a bit like Hal Ruhl try to say currently to 
<br />
George) begin to build an (infinite path) toward completion. Much more 
<br />
on this later.
<br />
BTW, Torkel Fraenkel's other book, on inexhaustibility,  is a good 
<br />
introduction for those autonomous progressions (as they are called in 
<br />
the literature), but we will need only the fact that some modal logics 
<br />
(the hypostases) remains invariant in those progressions for making the 
<br />
comp-physics , and all hypostatses, stable and recoverable. More later 
<br />
...
<br />
<br /><br />4) The 1-person and the 3- machine.
<br />
<br />They are not the same, and they will fight against each other 
<br />
&quot;forever&quot;. In case you worry: they can make progress so that such fight 
<br />
is less and less painful, or more and more civilized, that is by 
<br />
discussing around a table instead than with bombs and bloody war, but 
<br />
the tension between those two different view is not eliminable. Never, 
<br />
unless comp is false.
<br />
<br /><br />5) Lobian machines' theology
<br />
<br />The 1-person and the 3-person (3-machine) are just two arithmetical 
<br />
interpretation of the Plotinian hypostases. Those who have followed 
<br />
older posts, or have read my Plotinus paper, knows that there is 8 
<br />
hypostases. Later we will see that some of those hypostases (= 
<br />
points-of-view) will still be multiplied, indeed I expect some of them 
<br />
to lead to some graded algebra describing some quantum computer, ...
<br />
For each machine, its arithmetical hypostases defines its theology.
<br />
Propositional (self) &quot;theology&quot; is given primarily by the modal logic 
<br />
G*.
<br />
Propositional (self) &quot;science&quot; is given primarily by the modal logic G.
<br />
Pure propositional theology is given by G* minus G.
<br />
<br /><br />6) Lobian machines' physics
<br />
<br />Just particular hypostases corresponding intuitively to the way matter 
<br />
has to emerge as explained in the universal dovetailer argument.
<br />
<br /><br />7) Lobian machines' ethics
<br />
<br />Not so difficult, assuming comp. I will indeed only consider the ethics 
<br />
of the computationalist Lobian machine. One key is that the TRUTH of 
<br />
&quot;yes doctor&quot; entails the RIGHT of saying NO to the doctor. 
<br />
Computationalism *is* a religion somehow, and it can explain why it has 
<br />
to be a &quot;religion&quot;, and why it just cannot be used coercively on 
<br />
people.
<br />
Alas,  some NON-comp people could not tolerate the comp-people, and 
<br />
this will give rise to future conflicts, ...
<br />
Then computationalism is not (at all) an ethical panacea, and I will 
<br />
say some word of the type of conflicts occuring (in Platonia) between a 
<br />
large variety of comp-people.
<br />
<br />OK, I send this before putting it in the trash ... I expect to correct 
<br />
and complete this post slowly but surely, and your remarks could help, 
<br />
thanks.
<br />
<br />Bruno
<br />
<a href="http://iridia.ulb.ac.be/~marchal/">http://iridia.ulb.ac.be/~marchal/</a>
<br />
<br />--~--~---------~--~----~------------~-------~--~----~
<br />
You received this message because you are subscribed to the Google Groups &quot;Everything List&quot; group.
<br />
To post to this group, send email to everything-list.domain.name.hidden
<br />
To unsubscribe from this group, send email to everything-list-unsubscribe.domain.name.hidden
<br />
For more options, visit this group at <a href="http://groups.google.com/group/everything-list?hl=en">http://groups.google.com/group/everything-list?hl=en</a>
<br />
-~----------~----~----~----~------~----~------~--~---
<br />
<span id="received"><dfn>Received on</dfn> Fri Jan 18 2008 - 11:04:17 PST</span>
</div>
<!-- body="end" -->
<div class="foot">
<map id="navbarfoot" name="navbarfoot" title="Related messages">
<ul class="links">
<li><dfn>This message</dfn>: [ <a href="#start14368">Message body</a> ]</li>
<!-- lnext="start" -->
<li><dfn>Next message</dfn>: <a href="14369.html" title="Next message in the list">Russell Standish: "Re: What has Schmidhuber been up to"</a></li>
<li><dfn>Previous message</dfn>: <a href="14367.html" title="Previous message in the list">George Levy: "Re: dark energy"</a></li>
<li><dfn>In reply to</dfn>: <a href="14366.html" title="Message to which this message replies">Hal Ruhl: "Re: dark energy"</a></li>
<!-- lnextthread="start" -->
<li><dfn>Next in thread</dfn>: <a href="14383.html" title="Next message in this discussion thread">Mirek Dobsicek: "Re: SUMMARY"</a></li>
<li><a name="replies" id="replies"></a>
<dfn>Reply</dfn>: <a href="14383.html" title="Message sent in reply to this message">Mirek Dobsicek: "Re: SUMMARY"</a></li>
<!-- lreply="end" -->
</ul>
<ul class="links">
<li><a name="options3" id="options3"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg14368" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg14368" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg14368" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg14368" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</map>
</div>
<!-- trailer="footer" -->
<p><small><em>
This archive was generated by <a href="http://www.hypermail-project.org/">hypermail 2.3.0</a>
: Fri Feb 16 2018 - 13:20:14 PST
</em></small></p>
</body>
</html>
