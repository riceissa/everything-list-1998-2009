<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<meta name="generator" content="hypermail 2.3.0, see http://www.hypermail-project.org/" />
<title>Re: *THE* PUZZLE (was: ascension, Smullyan, ...) from Bruno Marchal on 2006-06-12 (everything)</title>
<meta name="Author" content="Bruno Marchal (marchal.domain.name.hidden)" />
<meta name="Subject" content="Re: *THE* PUZZLE (was: ascension, Smullyan, ...)" />
<meta name="Date" content="2006-06-12" />
<style type="text/css">
/*<![CDATA[*/
/* To be incorporated in the main stylesheet, don't code it in hypermail! */
body {color: black; background: #ffffff}
dfn {font-weight: bold;}
pre { background-color:inherit;}
.head { border-bottom:1px solid black;}
.foot { border-top:1px solid black;}
th {font-style:italic;}
table { margin-left:2em;}map ul {list-style:none;}
#mid { font-size:0.9em;}
#received { float:right;}
address { font-style:inherit ;}
/*]]>*/
.quotelev1 {color : #990099}
.quotelev2 {color : #ff7700}
.quotelev3 {color : #007799}
.quotelev4 {color : #95c500}
.period {font-weight: bold}
</style>
</head>
<body>
<div class="head">
<h1>Re: *THE* PUZZLE (was: ascension, Smullyan, ...)</h1>
<!-- received="Mon Jun 12 09:53:26 2006" -->
<!-- isoreceived="20060612165326" -->
<!-- sent="Mon, 12 Jun 2006 15:52:15 +0200" -->
<!-- isosent="20060612135215" -->
<!-- name="Bruno Marchal" -->
<!-- email="marchal.domain.name.hidden" -->
<!-- subject="Re: *THE* PUZZLE (was: ascension, Smullyan, ...)" -->
<!-- id="6612ffea901c87ebe4504bd65fc15257.domain.name.hidden" -->
<!-- charset="ISO-8859-1" -->
<!-- inreplyto="1149984050.255285.150230.domain.name.hidden" -->
<!-- expires="-1" -->
<map id="navbar" name="navbar">
<ul class="links">
<li>
<dfn>This message</dfn>:
[ <a href="#start9491" name="options1" id="options1" tabindex="1">Message body</a> ]
 [ More options (<a href="#options2">top</a>, <a href="#options3">bottom</a>) ]
</li>
<li>
<dfn>Related messages</dfn>:
<!-- unext="start" -->
[ <a href="9492.html" accesskey="d" title="Bruno Marchal: &quot;Re: *THE* PUZZLE (was: ascension, Smullyan, ...)&quot;">Next message</a> ]
[ <a href="9490.html" title="Tom Caylor: &quot;Re: *THE* PUZZLE (was: ascension, Smullyan, ...)&quot;">Previous message</a> ]
[ <a href="9483.html" title="Tom Caylor: &quot;Re: *THE* PUZZLE (was: ascension, Smullyan, ...)&quot;">In reply to</a> ]
<!-- unextthread="start" -->
[ <a href="9496.html" accesskey="t" title="Russell Standish: &quot;Re: *THE* PUZZLE (was: ascension, Smullyan, ...)&quot;">Next in thread</a> ]
 [ <a href="#replies">Replies</a> ]
<!-- ureply="end" -->
</li>
</ul>
</map>
<ul class="links">
<li><a name="options2" id="options2"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg9491" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg9491" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg9491" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg9491" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</div>
<!-- body="start" -->
<div class="mail">
<address class="headers">
<span id="from">
<dfn>From</dfn>: Bruno Marchal &lt;<a href="mailto:marchal.domain.name.hidden?Subject=Re%3A%20*THE*%20PUZZLE%20(was%3A%20ascension%2C%20Smullyan%2C%20...)">marchal.domain.name.hidden</a>&gt;
</span><br />
<span id="date"><dfn>Date</dfn>: Mon, 12 Jun 2006 15:52:15 +0200</span><br />
</address>
<br />
Le 11-juin-06, à 02:00, Tom Caylor a écrit :
<br />
<br /><br /><em class="quotelev1">&gt; If I may, I'd like to revisit why (the motivation) we are considering
</em><br />
<em class="quotelev1">&gt; functions from N to N.  I guess it is because all computations are
</em><br />
<em class="quotelev1">&gt; equivalent to taking a number from N (i.e. each uniquely meaningful
</em><br />
<em class="quotelev1">&gt; input of a computation can be put into a one-to-one correspondence with
</em><br />
<em class="quotelev1">&gt; a number from N, because there are countably many inputs) and produce a
</em><br />
<em class="quotelev1">&gt; number from N (same reasoning for output as for input).
</em><br />
<br /><br /><br />Yes, although the way you put it can be misleading. All computations 
<br />
comes from an application of some program on some input (always a 
<br />
positive integer or zero, I mean a natural number; or anything codable 
<br />
by a natural number). If the program P codes a total (everywhere 
<br />
defined) one-variable-function, then for each n each computation P(n) 
<br />
will stop. Note that to compute a function of one variable on *all* 
<br />
inputs we need to run it on all numbers, or at least to write a program 
<br />
generating its graph (set of all its couple of input-outputs, see below 
<br />
for examples).
<br />
<br /><br /><br /><br /><br /><em class="quotelev1">&gt; I guess that
</em><br />
<em class="quotelev1">&gt; you are interested in computations because this is what your comp is
</em><br />
<em class="quotelev1">&gt; based on.  Your &quot;sufficient level of substitution&quot; is a description of
</em><br />
<em class="quotelev1">&gt; a person with countably many symbols.  Right?
</em><br />
<br /><br /><br />Even with a finite number of symbols. Think of the motto: believing in 
<br />
comp is the belief that you can save your soul on a disk, or even in a 
<br />
(voluminous) book. Two symbols are enough. Well, actually one symbol is 
<br />
enough, because you can write a number n just with n strokes.
<br />
<br /><br /><br /><br /><br /><em class="quotelev1">&gt;
</em><br />
<em class="quotelev2">&gt;&gt; Note that a (one) computable function is an infinite object, but 
</em><br />
<em class="quotelev2">&gt;&gt; giving
</em><br />
<em class="quotelev2">&gt;&gt; that that infinite set is computable and generable from a code, the 
</em><br />
<em class="quotelev2">&gt;&gt; set
</em><br />
<em class="quotelev2">&gt;&gt; of computable functions is in bijection with the set of their codes,
</em><br />
<em class="quotelev2">&gt;&gt; which itself is in bijection with N, and so the infinite set of
</em><br />
<em class="quotelev2">&gt;&gt; infinite objects which are the computable function is in bijection 
</em><br />
<em class="quotelev2">&gt;&gt; with
</em><br />
<em class="quotelev2">&gt;&gt; N.
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; When you say &quot;infinite object&quot; here, you mean that the function
</em><br />
<em class="quotelev1">&gt; computes an infinite number of values, i.e. all the numbers in N.
</em><br />
<em class="quotelev1">&gt; Right?
</em><br />
<br /><br /><br />Yes. Examples,
<br />
The constant function 1 =
<br />
{(0, 1) (1,1) (2,1) (3,1) (4,1) (5,1) (6,1), (7,1) ... }
<br />
Factorial = {(0,1) (1,1) (2,2) (3,6) (4,24) (5,120) (6,720) (7,5040) 
<br />
...}
<br />
Successor = {(0,1) (1,2) (2,3) (3,4) (4,5) (5,6) (6,7) (7,8) ...}
<br />
Identity = {(0,0) (1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) ...}
<br />
...
<br />
All functions from N to N are infinite object.
<br />
Now, a computable function got a finite name/description/code/programs, 
<br />
etc. But we have just learned (by the diagonalization trick) that many 
<br />
programs (in any programming language or in any universal machine 
<br />
specification) does not compute total functions, but compute so-called 
<br />
partial functions, = those not necessarily defined everywhere.
<br />
<br /><br /><br /><br /><br /><em class="quotelev1">&gt; Even though the function is programmed with a finite number of
</em><br />
<em class="quotelev1">&gt; symbols, equivalent to a finite number from N.  A function programmed
</em><br />
<em class="quotelev1">&gt; with a finite number of symbols, say digits, I can think of as a finite
</em><br />
<em class="quotelev1">&gt; number, or if I put a decimal point in front, a rational number.
</em><br />
<br /><br /><br />Yes. I will just use the number appearing in the enumeration of the 
<br />
partial functions
<br />
F1, F2, F3, F4, F5, F6, F7, ...
<br />
So I will say for example that 4 is a Godel number of the function F4.
<br />
I guess all computer user knows that all programmable function (total 
<br />
or partial) will have an infinity of such godel number, because they 
<br />
have (necesarily) an infinity of programs (just think about dummy 
<br />
instructions). Later I will give a tool for proving this in all 
<br />
generality.
<br />
<br /><br /><br /><br /><br /><em class="quotelev1">&gt; This
</em><br />
<em class="quotelev1">&gt; is equivalent to saying that the rational numbers can be put in a
</em><br />
<em class="quotelev1">&gt; one-to-one correspondence (bijection) with N, which is true.
</em><br />
<br /><br />Right, but I'm not sure to understand your motivation for using 
<br />
rational numbers as code. Any set for which there is a computable 
<br />
bijection with N will do, so let us keep the simplest one: N.  OK?
<br />
<br /><br /><br /><br /><br /><em class="quotelev1">&gt; We can
</em><br />
<em class="quotelev1">&gt; see that this does not remain true if we allow for infinite programs,
</em><br />
<em class="quotelev1">&gt; i.e. a program defined by an infinite number of symbols/digits.
</em><br />
<br /><br />In general, an infinite programs can still be written with a finite 
<br />
number of symbols, like a real number can be written with a finite 
<br />
number of symbols chosen among {0,1,2,3,4,5,6,7,8,9}. Of course in 
<br />
general it will need an infinite number of occurences of those symbols. 
<br />
It is the length of the program which is infinite.
<br />
But there is no infinite programs (in arithmetical Platonia). Of course 
<br />
like Russell, you can conceive and study them but it in general the 
<br />
whole motivation of the notion of programs/names/description is really 
<br />
to capture something infinite by something finite.
<br />
Actually you can even consider programs based on infinite alphabets, 
<br />
even of any cardinality. But I don't see any motivations unless you 
<br />
want to study strongly non-comp philosophy. You will need advanced 
<br />
stuff in set theory, and also you have to masterize the &quot;finite&quot; theory 
<br />
before (so let us not try to put the car before the horse ...).
<br />
<br /><br /><br /><br /><br /><em class="quotelev1">&gt; The
</em><br />
<em class="quotelev1">&gt; number of such programs is equivalent to the cardinality of the reals
</em><br />
<em class="quotelev1">&gt; or the continuum.
</em><br />
<br /><br />Yes, but it is not standard to call them programs.
<br />
<br /><br /><br /><br /><br /><em class="quotelev1">&gt; So we have to keep in mind that &quot;infinite object&quot;
</em><br />
<em class="quotelev1">&gt; refers to the domain of the function, not the description of the
</em><br />
<em class="quotelev1">&gt; function.  Right?
</em><br />
<br /><br />The domain, or the range or the graph. The domain of f = the set of n 
<br />
such f(n) is defined, the range of f = the set of n such that there 
<br />
exist m such that f(m) = n, and the graph is the set of couples like I 
<br />
have illustrated above.
<br />
<br /><br /><br /><br /><br /><em class="quotelev2">&gt;&gt; There is just no algorithm which can generate
</em><br />
<em class="quotelev2">&gt;&gt; the sequence of codes of the computable functions from N to N. So,
</em><br />
<em class="quotelev2">&gt;&gt; although each fn is a computable function (from N to N), you cannot
</em><br />
<em class="quotelev2">&gt;&gt; diagonalize it for getting g, because to compute g on n, g(n) you need
</em><br />
<em class="quotelev2">&gt;&gt; to generate the n first programs corresponding to f1, f2, f3, ... fn,
</em><br />
<em class="quotelev2">&gt;&gt; and then apply it to n (and then add one), but you just will never 
</em><br />
<em class="quotelev2">&gt;&gt; been
</em><br />
<em class="quotelev2">&gt;&gt; able to give me a finite set of instructions for doing that. If {f1,
</em><br />
<em class="quotelev2">&gt;&gt; f2, f3, ...} are all computable function from N to N, and if the
</em><br />
<em class="quotelev2">&gt;&gt; sequence is complete (con,tains all such function) then g, although
</em><br />
<em class="quotelev2">&gt;&gt; mathematically well defined, is just not programmable.
</em><br />
<em class="quotelev2">&gt;&gt;
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; This seems to be a result of the fact that we have given *meaning* to
</em><br />
<em class="quotelev1">&gt; the symbols, by specifying that the symbols have to make sense in some
</em><br />
<em class="quotelev1">&gt; language.  This seems to imply that &quot;attributing meaning to symbols&quot; is
</em><br />
<em class="quotelev1">&gt; not algorithmically codable.
</em><br />
<br /><br /><br />You are right,we will have opportunities to come back on this.
<br />
<br /><br /><br /><br /><em class="quotelev1">&gt; If you could code it, then it would be
</em><br />
<em class="quotelev1">&gt; programmable (and even computable if it halts).
</em><br />
<em class="quotelev1">&gt; But then it would just
</em><br />
<em class="quotelev1">&gt; be a bunch of numbers being crunched without meaning.
</em><br />
<br /><br />This is a little fuzzy for me. We will come back on this.
<br />
<br /><br /><br /><br /><em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt; I've been wondering about this in the background for a while, so now I
</em><br />
<em class="quotelev1">&gt; can ask this question.  OK, I think I understand everything so far.
</em><br />
<em class="quotelev1">&gt; But...  if there are functions (in the list of *all* programmable
</em><br />
<em class="quotelev1">&gt; functions) which will run forever, and you cannot (computably?) know
</em><br />
<em class="quotelev1">&gt; which ones they are (otherwise you could solve the Halting problem?...
</em><br />
<br /><br /><br />We have not yet seen the halting problem. Our proof shows directly that 
<br />
we cannot, computably indeed, find those codes corresponding to total 
<br />
functions, *otherwize* we can enumerate them and prove 0 = 1 by 
<br />
diagonalization.
<br />
<br /><br /><br /><br /><br /><em class="quotelev1">&gt; or... at least by the digaonalization reasoning you've given),
</em><br />
<br /><br />Ah!  Yes, exactly. Everyone should be sure to understand this.
<br />
<br /><br /><br /><br /><em class="quotelev1">&gt; then
</em><br />
<em class="quotelev1">&gt; isn't the Universal Dovetailer going to run into one of these programs
</em><br />
<em class="quotelev1">&gt; and run forever?  Alternatively, if the UD executes the first
</em><br />
<em class="quotelev1">&gt; instruction of each program, there are a (countably) infinite number of
</em><br />
<em class="quotelev1">&gt; programs, so you would never get to the second instruction.
</em><br />
<em class="quotelev1">&gt; Alternatively again, are we really allowed to sort the infinite number
</em><br />
<em class="quotelev1">&gt; of programs so that we execute the one-instruction programs first,
</em><br />
<em class="quotelev1">&gt; followed by the two-instruction programs, etc.?  Isn't this
</em><br />
<em class="quotelev1">&gt; non-constructive?
</em><br />
<br /><br /><br />OK, you and Quentin have already solve this, I will not comment. Just a 
<br />
little summary in two points:
<br />
<br />1) The deep reason why we can hope (pray, bet on, ...) in the universal 
<br />
dovetailer is just Church thesis which is possible thanks to the fact 
<br />
the set of programmable partial(*) functions is enumerable and close 
<br />
for the diagonalization procedure (unlike the case of the total 
<br />
programmable function which gives a non recursively (mechanically) 
<br />
enumerable subset of the partial functions.
<br />
2) But so, to execute all programs, we have to *dovetail* so that we 
<br />
will not been stuck in some infinite computations.
<br />
<br /><br />(*) I include the total functions in the partial functions. A total 
<br />
function is a particular case of a function which is defined only on a 
<br />
subset of N, but here the subset is N itself. I will say a function is 
<br />
*strictly* partial when it is not total.
<br />
I will try to make a summary of the main definitions and theorems.
<br />
<br />Bruno
<br />
<a href="http://iridia.ulb.ac.be/~marchal/">http://iridia.ulb.ac.be/~marchal/</a>
<br />
<br /><br />--~--~---------~--~----~------------~-------~--~----~
<br />
You received this message because you are subscribed to the Google Groups &quot;Everything List&quot; group.
<br />
To post to this group, send email to everything-list.domain.name.hidden
<br />
To unsubscribe from this group, send email to everything-list-unsubscribe.domain.name.hidden
<br />
For more options, visit this group at <a href="http://groups.google.com/group/everything-list">http://groups.google.com/group/everything-list</a>
<br />
-~----------~----~----~----~------~----~------~--~---
<br />
<span id="received"><dfn>Received on</dfn> Mon Jun 12 2006 - 09:53:26 PDT</span>
</div>
<!-- body="end" -->
<div class="foot">
<map id="navbarfoot" name="navbarfoot" title="Related messages">
<ul class="links">
<li><dfn>This message</dfn>: [ <a href="#start9491">Message body</a> ]</li>
<!-- lnext="start" -->
<li><dfn>Next message</dfn>: <a href="9492.html" title="Next message in the list">Bruno Marchal: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<li><dfn>Previous message</dfn>: <a href="9490.html" title="Previous message in the list">Tom Caylor: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<li><dfn>In reply to</dfn>: <a href="9483.html" title="Message to which this message replies">Tom Caylor: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<!-- lnextthread="start" -->
<li><dfn>Next in thread</dfn>: <a href="9496.html" title="Next message in this discussion thread">Russell Standish: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<li><a name="replies" id="replies"></a>
<dfn>Reply</dfn>: <a href="9496.html" title="Message sent in reply to this message">Russell Standish: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<li><dfn>Reply</dfn>: <a href="9497.html" title="Message sent in reply to this message">Tom Caylor: "Re: *THE* PUZZLE (was: ascension, Smullyan, ...)"</a></li>
<!-- lreply="end" -->
</ul>
<ul class="links">
<li><a name="options3" id="options3"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg9491" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg9491" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg9491" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg9491" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</map>
</div>
<!-- trailer="footer" -->
<p><small><em>
This archive was generated by <a href="http://www.hypermail-project.org/">hypermail 2.3.0</a>
: Fri Feb 16 2018 - 13:20:11 PST
</em></small></p>
</body>
</html>
