<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<meta name="generator" content="hypermail 2.3.0, see http://www.hypermail-project.org/" />
<title>Key Post 1, toward Church Thesis and Lobian machine from Bruno Marchal on 2007-12-04 (everything)</title>
<meta name="Author" content="Bruno Marchal (marchal.domain.name.hidden)" />
<meta name="Subject" content="Key Post 1, toward Church Thesis and Lobian machine" />
<meta name="Date" content="2007-12-04" />
<style type="text/css">
/*<![CDATA[*/
/* To be incorporated in the main stylesheet, don't code it in hypermail! */
body {color: black; background: #ffffff}
dfn {font-weight: bold;}
pre { background-color:inherit;}
.head { border-bottom:1px solid black;}
.foot { border-top:1px solid black;}
th {font-style:italic;}
table { margin-left:2em;}map ul {list-style:none;}
#mid { font-size:0.9em;}
#received { float:right;}
address { font-style:inherit ;}
/*]]>*/
.quotelev1 {color : #990099}
.quotelev2 {color : #ff7700}
.quotelev3 {color : #007799}
.quotelev4 {color : #95c500}
.period {font-weight: bold}
</style>
</head>
<body>
<div class="head">
<h1>Key Post 1, toward Church Thesis and Lobian machine</h1>
<!-- received="Tue Dec  4 09:56:11 2007" -->
<!-- isoreceived="20071204175611" -->
<!-- sent="Tue, 4 Dec 2007 15:55:50 +0100" -->
<!-- isosent="20071204145550" -->
<!-- name="Bruno Marchal" -->
<!-- email="marchal.domain.name.hidden" -->
<!-- subject="Key Post 1, toward Church Thesis and Lobian machine" -->
<!-- id="5a02ed1cc68db554bc019c59c3a33075.domain.name.hidden" -->
<!-- charset="ISO-8859-1" -->
<!-- inreplyto="9d456703-172f-44ec-9723-a73d2185ba07.domain.name.hidden" -->
<!-- expires="-1" -->
<map id="navbar" name="navbar">
<ul class="links">
<li>
<dfn>This message</dfn>:
[ <a href="#start14291" name="options1" id="options1" tabindex="1">Message body</a> ]
 [ More options (<a href="#options2">top</a>, <a href="#options3">bottom</a>) ]
</li>
<li>
<dfn>Related messages</dfn>:
<!-- unext="start" -->
[ <a href="14292.html" accesskey="d" title="Jesse Mazer: &quot;RE: Relativity and QM compatibility&quot;">Next message</a> ]
[ <a href="14290.html" title="Bruno Marchal: &quot;Re: Cantor&#0039;s Diagonal&quot;">Previous message</a> ]
[ <a href="14288.html" title="David Nyman: &quot;Re: Cantor&#0039;s Diagonal&quot;">In reply to</a> ]
<!-- unextthread="start" -->
[ <a href="14294.html" accesskey="t" title="Mirek Dobsicek: &quot;Re: Key Post 1, toward Church Thesis and Lobian machine&quot;">Next in thread</a> ]
 [ <a href="#replies">Replies</a> ]
<!-- ureply="end" -->
</li>
</ul>
</map>
<ul class="links">
<li><a name="options2" id="options2"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg14291" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg14291" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg14291" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg14291" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</div>
<!-- body="start" -->
<div class="mail">
<address class="headers">
<span id="from">
<dfn>From</dfn>: Bruno Marchal &lt;<a href="mailto:marchal.domain.name.hidden?Subject=Re%3A%20Key%20Post%201%2C%20toward%20Church%20Thesis%20and%20Lobian%20machine">marchal.domain.name.hidden</a>&gt;
</span><br />
<span id="date"><dfn>Date</dfn>: Tue, 4 Dec 2007 15:55:50 +0100</span><br />
</address>
<br />
Hi David, Mirek, Tom, Barry and All,
<br />
<br />In the preceding post, I gave you an informal proof in naïve set theory 
<br />
that the set of functions from N to N was not enumerable.
<br />
<br />Note: the preceding post =
<br />
<a href="http://www.mail-archive.com/everything-list.domain.name.hidden/msg14063.html">http://www.mail-archive.com/everything-list.domain.name.hidden/msg14063.html</a>
<br />
<br /><br />It is not in my intention at all to convince you that Cantor's result 
<br />
is true. A problem which occurs is the many invocation of Gods. Cantor 
<br />
himself will hide paradoxes and also will discuss with theologians on 
<br />
those problems.
<br />
<br />Today we know Cantor's theorem is provable in reasonably sound accounts 
<br />
of sets, like Zermelo Fraenkel Set Theory, ZF.
<br />
<br />But it is not my purpose to dwelve into set theory. My purpose is 
<br />
computability theory.
<br />
<br /><br /><br />What happens if we try to restrict ourselves to *computable* functions 
<br />
from N to N, instead of *all* functions from N to N.
<br />
<br />In this case we would not be obliged to refer to Gods, those who were 
<br />
able to &quot;see&quot; an arbitrary and infinite long sequence of numbers.
<br />
<br />But we get somehow the anti-problem. How to define what is a computable 
<br />
function?
<br />
<br />We can hardly be satisfied by an anti-solution like:
<br />
<br />Anti-definition: A function from N to N is computable if it can be 
<br />
computed without any invocation to any Gods.
<br />
<br /><br /><br />So we have to find a more positive definition, and invoke *finite and 
<br />
humble* creature instead. Humble, because we have to be sure not 
<br />
attributing to them any magical and hard to define qualities like 
<br />
cleverness, intelligence, intuition or any god-like predicate.
<br />
<br /><br />So here is an informal &quot;definition&quot; of what is an (intuitively) 
<br />
computable function from N to N.
<br />
<br /><br />&quot;Definition&quot;: a function f is computable if there is a finite set of 
<br />
instructions such that a complete asshole can, on each n compute in a 
<br />
finite time the result f(n).
<br />
<br /><br />OK. &quot;complete asshole&quot; is probably a bit popular, and I will use the 
<br />
adverb &quot;unambiguously&quot; instead.
<br />
<br /><br />Also, what are the instructions? Whatever they are, they have to be 
<br />
described in some language, which has to be unambiguous (understandable 
<br />
by that humble finite creature).
<br />
<br /><br /><br />So here is a better &quot;definition&quot; of what is a computable function from 
<br />
N to N.
<br />
<br />A function f from N to N is said (intuitively) computable if there is a 
<br />
language L in which it is possible to describe unambiguously through a 
<br />
finite expression in L how, for any n to compute f(n) in a finite time.
<br />
<br /><br />The finite expression are intended to express the instructions. A 
<br />
language is the given of a finite alphabet A, and a subset L of 
<br />
unambiguous expressions. If A is a finite or enumerable alphabet, then 
<br />
I will denote by A°, the set of finite expressions written with the 
<br />
alphabet A. I recall that If A is finite or enumerable, then A° is 
<br />
enumerable too. Indeed, you can put an alphabetical order on all 
<br />
sequences of length 1, and then of length 2, etc.
<br />
Exemple: A = {S, K, (, ) }
<br />
Ordering the finite expressions, using the order &quot;K &lt; S &lt;  ( &lt; )&quot; on 
<br />
the alphabet:
<br />
<br />finite expressions=
<br />
K, S, (, ),     [length one]
<br />
KK, KS, K(, K), SK, SS, S(, S), (K, (S, ((, (), )K, )S, )(, )),    
<br />
[length two]
<br />
KKK , ...  [length 3]
<br />
KKKK, ... [length 4]
<br />
<br />Note that &quot;)))KK))S())&quot; is a finite expression on the alphabet. It is 
<br />
does not refer to a combinator, which are associated only to 
<br />
well-formed expressions, like, if you remember,  (K(SK)), or 
<br />
((S(KS))K), making a subset of the set of all (finite) expressions.
<br />
<br /><br />Now, two fundamental definitions:
<br />
<br />Universal Language:  A language L is universal if all computable 
<br />
functions (from N to N) can be described in L.
<br />
<br />Universal Machine: A machine M is universal if M understands L, and so 
<br />
M can actually compute the value f(n) of any computable function from 
<br />
its description in the universal language L and the input n.
<br />
(Note that  such a universal *machine*, should be describable itself by 
<br />
an expression in the universal language. We will come back on this 
<br />
later).
<br />
<br />Now the question is: Is there an universal language?  Is there a 
<br />
universal machine?
<br />
<br />Is that an obvious question? Definitions like above are not proof of 
<br />
existence.
<br />
<br /><br /><br />Traditionnaly here I do sometimes present a proof, by diagonalization, 
<br />
that there are no universal machine, and ask the student to find 
<br />
possible errors. Here I will NOT proceed like that and proceed directly 
<br />
instead.
<br />
<br />For this I will first consider the problem of the cardinality of the 
<br />
set of computable functions, and then provide more definitions.
<br />
<br /><br /><br />The cardinality of the set of computable functions.
<br />
<br />Well, if L is a language, it has a finite alphabet A. Then, the subset 
<br />
of its unambiguous expressions (for the instruction) is a subset of the 
<br />
set of all its finite expressions, which we have seen to be enumerable. 
<br />
So the set of computable functions from N to N is enumerable. By 
<br />
Cantor, the set of functions from N to N is not enumerable: thus there 
<br />
are drastically more uncomputable functions than computable functions.
<br />
<br />Definition: Perfect Universal Machine (or Language):  I will say that a 
<br />
universal machine (or language) is perfect, or secure, if the machine 
<br />
computes (or the language defines) only computable functions from N to 
<br />
N.
<br />
<br />By universality such a machine computes all computable functions from N 
<br />
to N.  By security or perfection, such machine computes thus all and 
<br />
only all computable functions from N to N. By the definition of a 
<br />
function from N to N (in a preceding post), this means that such a 
<br />
universal secure machine will, on any unambiguous expression 
<br />
representing its instructions, output a value f(n) for any n, after a 
<br />
finite time.
<br />
So a perfect universal machine, when following its instruction, never 
<br />
crash, by which I mean going in some loop or infinite task, well, that 
<br />
is, loosing the contact with the user or some neighborhood.
<br />
<br /><br /><br />Fundamental Theorem 1 : there are no *secure* universal machine.  All 
<br />
universal machine, if there is ever one, have to be imperfect.
<br />
<br /><br />Proof (reductio ad absurdo)
<br />
<br />Suppose there is a secure universal machine M. The set of expressions 
<br />
it can compute provide a secure universal language L. That set is not 
<br />
only enumerable (given that it is a subset of an enumerable set) but 
<br />
above all, it can be enumerated effectively (by the &quot;ashole&quot;). Indeed 
<br />
the set of all unambiguous expressions, which, by perfection, describes 
<br />
computable functions from N to N,  is enumerable  by the method 
<br />
described above. Assuming the existence of such an universal secure 
<br />
language, we can effectively enumerate all the computable functions 
<br />
from N to N: f_1 f_2  f_3  f_4  f_5  f_6  f_7  f_8 ... where f_i 
<br />
represents the function computed by the i-th expression.
<br />
<br />But then the function g defined on each n by
<br />
<br />g(n) = f_n (n) + 1
<br />
<br />is  a computable function from N to N. To compute g on 777, for 
<br />
example, search the 777th expression in L by the method above, and 
<br />
apply it on 777, then add 1.
<br />
<br />But g cannot be computed by the secure universal machine M: indeed, if 
<br />
M compute g, it means there is an expression in L explaining how to 
<br />
compute g, and thus there is a k such that g = f_k, but then, applying 
<br />
g on its number:
<br />
<br />g(k) = f_k (k) on one hand, (presence of f_k in the list by 
<br />
universality) and
<br />
<br />g(k) = f_k(k) + 1 on the other hand, by definition of g.
<br />
<br />That is f_(k) = f_k (k) + 1
<br />
<br />But the machine never crashes and computes all and only all functions 
<br />
from N to N, so f_k(k) is a number, so I can substract it on both 
<br />
sides, giving 0 = 1. Contradiction. QED.
<br />
<br /><br />Remarks: the proof looks like Cantor proof that N^N is not enumerable. 
<br />
Here we know at the start that N^N, once restricted to computable 
<br />
functions, is enumerable. So if we know that a machine is a secure 
<br />
machine, we know that (by definition) all its expression defines 
<br />
functions from N to N, so we know that the machine cannot be universal. 
<br />
If we believe that a machine is a universal, then we can deduce two 
<br />
things: it has to compute some other beats Bs. Then, no set of 
<br />
instruction can for sure distinguish the  ... instructions defining 
<br />
functions from N to N and the Bs.
<br />
Proof: from such a set of instruction you could securized the universal 
<br />
machine, and get a perfecr one, which is impossible by the 1.
<br />
<br /><br /><br />Any machine M is left with a choice: security or universality, if that 
<br />
exists. But never both!
<br />
<br />But does a universal language, and its corresponding universal (and 
<br />
thus insecure) machine, really exist?
<br />
<br />We still don't know that!
<br />
<br />That means: does it exist a machine computing all computable functions? 
<br />
Equivalently: does it exist a universal language in which all 
<br />
computable function can be described by an expression.
<br />
<br />Of course now we know that if such a universal machine exists, it will 
<br />
be insecure and will compute, not just all computable functions from N 
<br />
to N, but also other sort of beast.
<br />
<br /><br />So, as you know, Church did *define* a computable function by a 
<br />
function computable by a lambda expression, in its conversion calculus.
<br />
<br />Kleene tought it could refute Church's pretension of universality, by 
<br />
*diagonalising* against the set of lambda expressions.
<br />
<br />Let us look what happens. We don't have to define the lambda 
<br />
expressions or any other candidate to universality to make the 
<br />
following reasoning, which is the same as above, yet in a different 
<br />
context again! We are now in the context of someone presenting us with 
<br />
a well specified language L and pretending it is universal: it does 
<br />
compute all computable functions from N to N, he says!
<br />
<br />Now, the unambiguous expressions U_i of the language L * can* again be 
<br />
effectively enumerated:
<br />
<br />U_1  U_2  U_3  U_4 U_5 ...
<br />
<br />Each expression like that denotes now either a computable function from 
<br />
N to N, or as we have to expect something else. And we have to expect 
<br />
they are no computable means to distinguish which U_i represents 
<br />
functions from N to N, and which represents the other beast. Now, the 
<br />
only thing which can happen when following instruction and not giving a 
<br />
number as output, in this case, is that the process of computation run 
<br />
for ever.
<br />
<br />Due to this, we have an argument for the consistency of Church thesis. 
<br />
Indeed, the diagonalisation above, where now the f_i are the *partial 
<br />
computable functions*, meaning they are from N to N, OR from a subset 
<br />
of N to N, does no more lead to a contradiction. That f_i is the 
<br />
perhaps total perhaps not, function computed by the U_i:
<br />
<br />f_1 f_2  f_3  f_4  f_5  f_6  f_7  f_8
<br />
<br />Yes the function g defined, (but no more necessarily on each n) by
<br />
<br /><br />g(n) = f_n (n) + 1
<br />
<br />&nbsp;&nbsp;can be represented by an expression in the language. So there is a k 
<br />
such that g = f_k indeed.
<br />
<br />And thus g(k) = f_k(k),
<br />
<br />and g(k) = f_k(k)+1
<br />
<br />Right. So what happens if the universal machine compute g(k) ?
<br />
<br />Well, in the computer jargon, the machine crash. The poor humble 
<br />
creature go in loop, or in some infinite task without ever any thought 
<br />
for the user until this one reboot the system. But thanks to that 
<br />
crashing, Church thesis remains consistent.
<br />
<br />I have to go ...
<br />
<br />Please ask questions. By experience I know this can be confusing: we do 
<br />
always the same diagonalisation, and get different results. Of course 
<br />
the premises are different. I let you think a bit, before resuming and 
<br />
proceeding trough. Please, ask questions if anything remains unclear.
<br />
<br />The motivation is that a Lobian Machine will be mainly a sort of 
<br />
enlightened universal machine, i.e. a universal machine knowing that 
<br />
she is universal. &quot;knowing&quot; in a very weak and technical sense which 
<br />
will be made precise in due course.
<br />
<br />Bruno
<br />
<br /><br /><br /><a href="http://iridia.ulb.ac.be/~marchal/">http://iridia.ulb.ac.be/~marchal/</a>
<br />
<br /><br />--~--~---------~--~----~------------~-------~--~----~
<br />
You received this message because you are subscribed to the Google Groups &quot;Everything List&quot; group.
<br />
To post to this group, send email to everything-list.domain.name.hidden
<br />
To unsubscribe from this group, send email to everything-list-unsubscribe.domain.name.hidden
<br />
For more options, visit this group at <a href="http://groups.google.com/group/everything-list?hl=en">http://groups.google.com/group/everything-list?hl=en</a>
<br />
-~----------~----~----~----~------~----~------~--~---
<br />
<span id="received"><dfn>Received on</dfn> Tue Dec 04 2007 - 09:56:11 PST</span>
</div>
<!-- body="end" -->
<div class="foot">
<map id="navbarfoot" name="navbarfoot" title="Related messages">
<ul class="links">
<li><dfn>This message</dfn>: [ <a href="#start14291">Message body</a> ]</li>
<!-- lnext="start" -->
<li><dfn>Next message</dfn>: <a href="14292.html" title="Next message in the list">Jesse Mazer: "RE: Relativity and QM compatibility"</a></li>
<li><dfn>Previous message</dfn>: <a href="14290.html" title="Previous message in the list">Bruno Marchal: "Re: Cantor&#0039;s Diagonal"</a></li>
<li><dfn>In reply to</dfn>: <a href="14288.html" title="Message to which this message replies">David Nyman: "Re: Cantor&#0039;s Diagonal"</a></li>
<!-- lnextthread="start" -->
<li><dfn>Next in thread</dfn>: <a href="14294.html" title="Next message in this discussion thread">Mirek Dobsicek: "Re: Key Post 1, toward Church Thesis and Lobian machine"</a></li>
<li><a name="replies" id="replies"></a>
<dfn>Reply</dfn>: <a href="14294.html" title="Message sent in reply to this message">Mirek Dobsicek: "Re: Key Post 1, toward Church Thesis and Lobian machine"</a></li>
<li><dfn>Reply</dfn>: <a href="14296.html" title="Message sent in reply to this message">Russell Standish: "Re: Key Post 1, toward Church Thesis and Lobian machine"</a></li>
<!-- lreply="end" -->
</ul>
<ul class="links">
<li><a name="options3" id="options3"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg14291" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg14291" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg14291" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg14291" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</map>
</div>
<!-- trailer="footer" -->
<p><small><em>
This archive was generated by <a href="http://www.hypermail-project.org/">hypermail 2.3.0</a>
: Fri Feb 16 2018 - 13:20:14 PST
</em></small></p>
</body>
</html>
