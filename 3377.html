<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
<meta name="generator" content="hypermail 2.3.0, see http://www.hypermail-project.org/" />
<title>Diagonalisation 1 (Answers) from Marchal on 2001-10-18 (everything)</title>
<meta name="Author" content="Marchal (marchal.domain.name.hidden)" />
<meta name="Subject" content="Diagonalisation 1 (Answers)" />
<meta name="Date" content="2001-10-18" />
<style type="text/css">
/*<![CDATA[*/
/* To be incorporated in the main stylesheet, don't code it in hypermail! */
body {color: black; background: #ffffff}
dfn {font-weight: bold;}
pre { background-color:inherit;}
.head { border-bottom:1px solid black;}
.foot { border-top:1px solid black;}
th {font-style:italic;}
table { margin-left:2em;}map ul {list-style:none;}
#mid { font-size:0.9em;}
#received { float:right;}
address { font-style:inherit ;}
/*]]>*/
.quotelev1 {color : #990099}
.quotelev2 {color : #ff7700}
.quotelev3 {color : #007799}
.quotelev4 {color : #95c500}
.period {font-weight: bold}
</style>
</head>
<body>
<div class="head">
<h1>Diagonalisation 1 (Answers)</h1>
<!-- received="Thu Oct 18 10:27:38 2001" -->
<!-- isoreceived="20011018172738" -->
<!-- sent="Thu Oct 18 10:27:38 2001" -->
<!-- isosent="20011018172738" -->
<!-- name="Marchal" -->
<!-- email="marchal.domain.name.hidden" -->
<!-- subject="Diagonalisation 1 (Answers)" -->
<!-- id="200110181726.TAA11828.domain.name.hidden" -->
<!-- charset="US-ASCII" -->
<!-- expires="-1" -->
<map id="navbar" name="navbar">
<ul class="links">
<li>
<dfn>This message</dfn>:
[ <a href="#start3377" name="options1" id="options1" tabindex="1">Message body</a> ]
 [ More options (<a href="#options2">top</a>, <a href="#options3">bottom</a>) ]
</li>
<li>
<dfn>Related messages</dfn>:
<!-- unext="start" -->
[ <a href="3378.html" accesskey="d" title="Pete Carlton: &quot;Re: ODP: Free will/consciousness/ineffability&quot;">Next message</a> ]
[ <a href="3376.html" title="Marchal: &quot;Re: random, was Predictions &#0038; duplications&quot;">Previous message</a> ]
<!-- unextthread="start" -->
<!-- ureply="end" -->
</li>
</ul>
</map>
<ul class="links">
<li><a name="options2" id="options2"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg3377" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg3377" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg3377" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg3377" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</div>
<!-- body="start" -->
<div class="mail">
<address class="headers">
<span id="from">
<dfn>From</dfn>: Marchal &lt;<a href="mailto:marchal.domain.name.hidden?Subject=Re%3A%20Diagonalisation%201%20(Answers)">marchal.domain.name.hidden</a>&gt;
</span><br />
<span id="date"><dfn>Date</dfn>: Thu Oct 18 10:27:38 2001</span><br />
</address>
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To all victims of certainties.
<br />
<br /><br /><br />Hi all,
<br />
<br />Thanks for those who makes out-of-line comments of
<br />
Diagonalisation 1.
<br />
I give the two promised solutions.
<br />
If you have forget the problem, please reread
<br />
<a href="http://www.escribe.com/science/theory/m3079.html">http://www.escribe.com/science/theory/m3079.html</a>
<br />
<br />The long term goal of this thread is G*, I recall.
<br />
Apology for those who would know those things.
<br />
<br />The others can take their time (it's a long post)
<br />
for being sure everything is clear. 
<br />
Any questions and/or remarks are welcome, 'course.
<br />
<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;***
<br />
<br />I rewrite the paradox (quoting myself):
<br />
<br /><br /><em class="quotelev1">&gt;I will say that a function f is computable if there is
</em><br />
<em class="quotelev1">&gt;a well defined formal language FL in which I can explained
</em><br />
<em class="quotelev1">&gt;non ambiguously how to compute f on arbitrary input (number).
</em><br />
<br /><br />I recall the functions are supposed to be functions whith
<br />
inputs in N and outputs in N. The functions are supposed to be
<br />
defined on *any* natural numbers.
<br />
<br /><br /><em class="quotelev1">&gt;I must be able to recognise if an expression in my language
</em><br />
<em class="quotelev1">&gt;is a grammaticaly correct definition of a function, that is
</em><br />
<em class="quotelev1">&gt;syntax error must be recoverable.
</em><br />
<em class="quotelev1">&gt;All expression in the language must be of finite length, and
</em><br />
<em class="quotelev1">&gt;the alphabet (the set of symbols) of the language is asked to
</em><br />
<em class="quotelev1">&gt;be finite.
</em><br />
<em class="quotelev1">&gt;Now all finite strings, a fortiori the grammatically correct
</em><br />
<em class="quotelev1">&gt;one, form a countable set. Just use the lexicographic order
</em><br />
<em class="quotelev1">&gt;defined above.
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;So the set of function computable with FL is countable. 
</em><br />
<em class="quotelev1">&gt;A synonym of countable is *enumerable*, and is used by
</em><br />
<em class="quotelev1">&gt;computer scientist, so I will also use it. 
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;So I can enumerate the functions computable with FL, that is
</em><br />
<em class="quotelev1">&gt;I can put them in sequence like f_0, f_1, f_2, f_3, ...
</em><br />
<em class="quotelev1">&gt;going through all functions computable in or with FL.
</em><br />
<br /><br />Sure.
<br />
<br /><br /><em class="quotelev1">&gt;Let us consider the function g defined again by
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;                   g(n) = f_n(n) + 1
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;Now, g is not only well defined, but is even computable.
</em><br />
<br /><br />Because each f_i are. It follows from our hypothesis. Of course
<br />
adding one is a computable operation.
<br />
<br /><br /><em class="quotelev1">&gt;To compute it on n, just search in the enumeration f_i the nth
</em><br />
<em class="quotelev1">&gt;function, apply it to n (this gives an answer because the f_i
</em><br />
<em class="quotelev1">&gt;are computable) and add 1.
</em><br />
<br /><br />So g is indeed computable.
<br />
<br /><br /><em class="quotelev1">&gt;So, there is a number k such that g = f_k, but then, again
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;                g(k) = f_k(k) = f_k(k) + 1
</em><br />
<em class="quotelev1">&gt;
</em><br />
<em class="quotelev1">&gt;But f_k(k) is a well defined number (f_k is computable), and
</em><br />
<em class="quotelev1">&gt;no numbers can be equal to &quot;itself + 1&quot;. Contradiction.
</em><br />
<br /><em class="quotelev1">&gt;Could the set of computable functions in FL be uncountable, after
</em><br />
<em class="quotelev1">&gt;all, or is g not expressible in FL, or what?
</em><br />
<br /><br />The expression &quot;computable functions in FL&quot; is an abbreviation
<br />
for the &quot;computable functions *definissable* by an expression (a
<br />
string, a list, a number) in FL&quot;.
<br />
So, obviously, through the lexical ordering, the set of functions
<br />
computable in FL is countable, (enumerable, bijective with N).
<br />
By the same token the function g is obviously computable.
<br />
<br />Yet, we have not prove that this set is uncountable.
<br />
So what?
<br />
<br />For g being computable, it was important that the f_i could
<br />
be enumerated (unlike the f_i in Cantor proof which rely in
<br />
arbitrary order in Plato heaven).
<br />
<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THE FIRST WAY TO AVOID THE PARADOX
<br />
<br /><br />1 The first way to avoid the paradox consist in
<br />
<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;precising our definition of LF: a formal language
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defining computable function from N to N, and defining
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*only* computable function.
<br />
<br />That is we suppose all expressions in LF computes only
<br />
functions defined on all their arguments, the programs or
<br />
the machines computing them stop for any arguments. LF
<br />
defines only so called *total* computable functions.
<br />
<br />In that case, (unless you believe 1 = 0), you are forced
<br />
to believe that the reasoning above shows only that the
<br />
function g, although total computable, is not LF expressible.
<br />
You cannot defined it in LF. LF has failed to capture the set
<br />
of *all* total computable functions. There is no k such that
<br />
the diagonal function g = f_k, f_k enumerating the LF-computable 
<br />
functions. This gives:
<br />
<br /><br />THEOREM 1 there is no universal language capable of defining
<br />
all and only all total computable functions.
<br />
<br />In term of the machine computing the functions described in
<br />
a language:
<br />
<br />THEOREM 1 there is no universal machine computing all and only
<br />
all total computable functions.
<br />
<br />In term of the enumeration of the f_i, the THEOREM 1, looks
<br />
like CANTOR theorem:
<br />
<br />THEOREM 1 the set of machines (programs, expressions),
<br />
computing (programming, defining), total computable function
<br />
is not algorithmically countable. The logician say: not
<br />
recursively enumerable.
<br />
<br />You cannot generate all and only all names of the total computable
<br />
functions.
<br />
<br />Algebraist like to say a set is *closed* for an operation defined
<br />
in that set when the operation never leads ouside the set.
<br />
So an algebraic version of THEOREM 1 is
<br />
<br />THEOREM 1 The set of (expression computing) all and only all
<br />
total computable  function is not closed for the diagonalisation 
<br />
operation.
<br />
<br /><br />CONSEQUENCES If you have a language L computing only total
<br />
computable functions, then you can build a new total computable
<br />
function outside the class defined by L.
<br />
<br />This gives a tool for the refutation of all naive Pythagorian
<br />
School, believing that they can capture formally the set
<br />
of all and only all total computable functions.
<br />
<br />Exemple: Suppose a naive Pythagorician believe that all 
<br />
computable functions can be put into the form of the class of
<br />
functions defined by a positive polynomial: like &quot;5x^3 + 2x^2 + 3&quot;.
<br />
The set of those polynomes is obviously recursively enumerable. 
<br />
Let p_i be an enumeration of the polynomes. So the function
<br />
g such that g(n) = p_n(n) + 1 gives a non positive polynomial 
<br />
computable function. Refuting the naive Pythagorician.
<br />
<br />You can add g to the list of polynoms, of course, and you get
<br />
a new class of total computable functions, so that you can
<br />
diagonalise it again, and again, and again ..., and then
<br />
again again, ... iterating in the transfinite, for better
<br />
sub-approximations of the set of the everywhere defined machines.
<br />
<br />&nbsp;
<br />
<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;THE SECOND WAY TO AVOID THE PARADOX
<br />
<br /><br />The THEOREM 1 says that you cannot find a universal language
<br />
capable of defining all and only all total computable functions.
<br />
<br />A question remains: would it be possible that there exists a
<br />
universal language capable of defining all total computable
<br />
functions? (dropping the &quot;and *only* all&quot;).
<br />
<br />Well, there is a thesis for that effect. Indeed all attempt
<br />
of defining all computable functions leads to the same
<br />
class of computable functions (from Babbage, Post, Church, Turing,
<br />
... to Java, C++, ... to Deutsch Universal Quantum Machines).
<br />
So a version of Church thesis is that FORTRAN (let us say) is
<br />
a language defining all total computable functions (but then
<br />
by theorem 1, computing not only those total functions).
<br />
<br />CHURCH THESIS There exists a universal language. 
<br />
(and FORTRAN is the one).
<br />
<br />In term of machine : There exits a universal machine
<br />
(and the interpreter LISP is the one).
<br />
<br /><br />As a consequence of theorem 1, we can expect that if such
<br />
a universal language exists (i.e. Church thesis) then it will 
<br />
defined all total functions, but certainly not all *and only* 
<br />
all total functions.
<br />
That is, it will defined all total functions *and other sort
<br />
of beast* as a necessary gift.
<br />
<br />So the second way to avoid the paradox consist in dropping the
<br />
&quot;and only&quot; in &quot;language capable of defining all and only all 
<br />
total computable functions&quot;. We precise our formal system in
<br />
a more liberal way by dropping the totality constraint.
<br />
<br /><br />What does happen with the diagonalisation, with such a universal
<br />
language?  (Let us take FORTRAN for fixing the idea).
<br />
Well, you certainly can generate mechanically (recursively enumerate)
<br />
the list of all programs FORTRAN, still by lexicographical order.
<br />
So let F_i be an enumeration of the fortran programs.
<br />
<br />The diagonal function g, such that g(n) = F_n(n) + 1, is certainly 
<br />
programmable, just because you can write a generator of the F_i, 
<br />
and  an applicator of the F_i on an input i, and you have an adder
<br />
for the &quot;+ 1&quot;.
<br />
<br />So there is certainly a F_k such that g = F_k.
<br />
<br />So what?  What will happen when you run g_k(k)?
<br />
<br />One thing is sure, if the machine stop on g_k(k), then
<br />
g_k(k) = g_k(k) + 1. So the machine will simply not stop!
<br />
<br />In the computer scientist jargon we say that the universal
<br />
machine crash. The machine get on his/her/it way, remain
<br />
silent, and simply does not stop.
<br />
<br />This proves g is undefined on k, its own number in the
<br />
enumeration of the programs. g is not a total computable
<br />
functions (being not defined everywhere
<br />
<br />So we get
<br />
<br />THEOREM 2 All languages (machines) defining (computing)
<br />
all total computable functions, defined automatically
<br />
a vaster set containing *partial* computable functions.
<br />
In particular all diagonal functions g are undefined
<br />
on their own code.
<br />
<br />We get immediately (with Church Thesis), the insolubility
<br />
result:
<br />
<br />THEOREM 3 there is no program (machines) capable of deciding if 
<br />
the code of F_i correspond to a total function or not.
<br />
Proof: Because, if that was the case, you could mechanically
<br />
extract a recursive enumeration of the total computable
<br />
function by deleting the code of the non total functions in
<br />
the enumeration of the F_i. (contradicting theorem 1).
<br />
<br />THEOREM 4 (Incompleteness):
<br />
<br />Any theory in which you can represent the (total or partial)
<br />
computable functions cannot be complete.
<br />
<br />That is for any such theory  you can find true proposition which 
<br />
cannot be proved in the theory.
<br />
<br />Proof:
<br />
If the theory was complete, that is capable of proving all
<br />
true propositions expressible in its language (supposed being
<br />
enough rich for representing the partial recursive functions), 
<br />
then you could use the theory again for extracting a recursive 
<br />
enumeration 
<br />
of the total computable functions (by deleting again the code of 
<br />
the non total functions in the enumeration of the F_i (and this
<br />
you do by testing the proposition &quot;F_i is not-total&quot; in your 
<br />
complete theory))).
<br />
<br />(Peano Arithmetic or Zermelo Fraenkel Set Theory are exemples of such
<br />
theories, i.e. rich enough for representing the F_i. But showing 
<br />
this, although easy, is tedious, a little like programming in assembly
<br />
language). Any axiomatisable extension of those theories succumb
<br />
the same godelian incompleteness fate.
<br />
<br />Bruno
<br />
<span id="received"><dfn>Received on</dfn> Thu Oct 18 2001 - 10:27:38 PDT</span>
</div>
<!-- body="end" -->
<div class="foot">
<map id="navbarfoot" name="navbarfoot" title="Related messages">
<ul class="links">
<li><dfn>This message</dfn>: [ <a href="#start3377">Message body</a> ]</li>
<!-- lnext="start" -->
<li><dfn>Next message</dfn>: <a href="3378.html" title="Next message in the list">Pete Carlton: "Re: ODP: Free will/consciousness/ineffability"</a></li>
<li><dfn>Previous message</dfn>: <a href="3376.html" title="Previous message in the list">Marchal: "Re: random, was Predictions &#0038; duplications"</a></li>
<!-- lnextthread="start" -->
<!-- lreply="end" -->
</ul>
<ul class="links">
<li><a name="options3" id="options3"></a><dfn>Contemporary messages sorted</dfn>: [ <a href="date.html#msg3377" title="Contemporary messages by date">by date</a> ] [ <a href="index.html#msg3377" title="Contemporary discussion threads">by thread</a> ] [ <a href="subject.html#msg3377" title="Contemporary messages by subject">by subject</a> ] [ <a href="author.html#msg3377" title="Contemporary messages by author">by author</a> ] [ <a href="attachment.html" title="Contemporary messages by attachment">by messages with attachments</a> ]</li>
</ul>
</map>
</div>
<!-- trailer="footer" -->
<p><small><em>
This archive was generated by <a href="http://www.hypermail-project.org/">hypermail 2.3.0</a>
: Fri Feb 16 2018 - 13:20:07 PST
</em></small></p>
</body>
</html>
